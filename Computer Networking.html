<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.428571; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; font-size-adjust: inherit; font-kerning: inherit; font-variant-alternates: inherit; font-variant-ligatures: inherit; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-variant-position: inherit; font-feature-settings: inherit; font-optical-sizing: inherit; font-variation-settings: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right-width: 0px; border-right-style: none; border-right-color: currentcolor; background-color: inherit; }
.CodeMirror-linenumber { }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; padding-bottom: 0px !important; }
  .typora-export * { print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: medium; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: medium !important; border-style: none !important; border-color: currentcolor !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom-width: 0px; border-bottom-style: none; border-bottom-color: currentcolor; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: medium; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex: 2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.428571rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left-width: 28px; border-left-style: solid; border-left-color: transparent; border-right-width: 28px; border-right-style: solid; border-right-color: transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right-width: 8px; border-right-style: solid; border-right-color: transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: medium !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right-width: 30px; border-right-style: solid; border-right-color: transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right-width: medium; border-right-style: none; border-right-color: currentcolor; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right-width: medium; border-right-style: none; border-right-color: currentcolor; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    pre {
        page-break-inside: avoid;
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

/*.html-for-mac {
    --item-hover-bg-color: #E6F0FE;
}*/

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
    opacity: 0.4;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

.menu-item-container a.menu-style-btn {
    background-color: #f5f8fa;
    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); 
}


 @media print { @page {margin: 0 0 0 0;} body.typora-export {padding-left: 0; padding-right: 0;} #write {padding:0;}}
</style><title>Computer Networking</title>
</head>
<body class='typora-export'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='comp-2322-computer-networking'><span>COMP 2322 Computer Networking</span></h1><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n0"><a class="md-toc-inner" href="#comp-2322-computer-networking">COMP 2322 Computer Networking</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n3"><a class="md-toc-inner" href="#00-introduction"><u>00. Introduction:</u></a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n9"><a class="md-toc-inner" href="#01-computer-networks-and-the-internet"><u>01. Computer Networks and the Internet</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n10"><a class="md-toc-inner" href="#11-internet">1.1 Internet</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n20"><a class="md-toc-inner" href="#nuts-and-bolts-view">"nuts and bolts" view</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n37"><a class="md-toc-inner" href="#service-view">Service view</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n46"><a class="md-toc-inner" href="#12-protocol">1.2 Protocol</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n55"><a class="md-toc-inner" href="#13-network-structure">1.3 Network structure</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n59"><a class="md-toc-inner" href="#network-edge">Network edge</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n65"><a class="md-toc-inner" href="#access-networks--physical-media">Access networks &amp; physical media</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n76"><a class="md-toc-inner" href="#住宅接入网络-dsl--cable">住宅接入网络 DSL &amp; cable</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n100"><a class="md-toc-inner" href="#access-network-digital-subscriber-line-dsl">Access network: Digital Subscriber Line (DSL)</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n119"><a class="md-toc-inner" href="#access-network-cable-network">Access network: cable network</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n156"><a class="md-toc-inner" href="#企业接入网络-ethernet">企业接入网络 (Ethernet)</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n160"><a class="md-toc-inner" href="#无线接入网络-wireless">无线接入网络 Wireless</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n168"><a class="md-toc-inner" href="#physical-media-物理媒体"><strong>Physical media (物理媒体)</strong> </a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n185"><a class="md-toc-inner" href="#network-core">Network core</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n193"><a class="md-toc-inner" href="#packet-switching-分组交换">packet switching 分组交换</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n227"><a class="md-toc-inner" href="#circuit-switching-电路交换">circuit switching 电路交换</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n248"><a class="md-toc-inner" href="#packet-switching-vs-circuit-switching">Packet switching vs circuit switching</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n253"><a class="md-toc-inner" href="#14-internet-structure-and-isp">1.4 Internet structure and ISP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n254"><a class="md-toc-inner" href="#internet-structure">Internet structure</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n279"><a class="md-toc-inner" href="#isp的三个层次和连接">ISP的三个层次和连接</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n305"><a class="md-toc-inner" href="#15-performance-loss-delay-throughput">1.5 Performance: loss, delay, throughput</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n307"><a class="md-toc-inner" href="#loss-and-delay">loss and delay</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n312"><a class="md-toc-inner" href="#four-sources-of-packet-delay">Four sources of packet delay</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n351"><a class="md-toc-inner" href="#throughput-吞吐量">throughput 吞吐量</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n370"><a class="md-toc-inner" href="#16-protocol-layers-service-models">1.6 Protocol layers, service models</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n371"><a class="md-toc-inner" href="#protocol-layers-协议层次">protocol layers 协议层次</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n391"><a class="md-toc-inner" href="#service-models">Service models</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n393"><a class="md-toc-inner" href="#internet-protocol-stack">Internet protocol stack</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n398"><a class="md-toc-inner" href="#isoosi-reference-model">ISO/OSI reference model</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n411"><a class="md-toc-inner" href="#encapsulation-封装和解封装">Encapsulation 封装和解封装</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n420"><a class="md-toc-inner" href="#02-application-layer-交换报文实现网络应用"><u>02. Application layer 交换报文，实现网络应用</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n425"><a class="md-toc-inner" href="#21-principles-of-network-applications">2.1 principles of network applications</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n436"><a class="md-toc-inner" href="#client-server">Client-server</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n446"><a class="md-toc-inner" href="#peer-to-peer-p2p">peer-to-peer (P2P)</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n455"><a class="md-toc-inner" href="#inter-process-communication-进程通信">Inter-process communication 进程通信</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n468"><a class="md-toc-inner" href="#addressing-processes">Addressing processes</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n477"><a class="md-toc-inner" href="#what-transport-service-does-an-app-need">What transport service does an app need?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n504"><a class="md-toc-inner" href="#internet-transport-layer-services">Internet transport layer services</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n518"><a class="md-toc-inner" href="#internet-apps-application--transport-layer-protocols">Internet apps: application / transport layer protocols</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n521"><a class="md-toc-inner" href="#22-web-and-http">2.2 Web and HTTP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n522"><a class="md-toc-inner" href="#web">Web</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n532"><a class="md-toc-inner" href="#http">HTTP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n544"><a class="md-toc-inner" href="#non-persistent-http--persistent-http">Non-persistent HTTP &amp; Persistent HTTP</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n556"><a class="md-toc-inner" href="#non-persistent-http">Non-persistent HTTP</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n569"><a class="md-toc-inner" href="#persistent-http">Persistent HTTP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n581"><a class="md-toc-inner" href="#http-message-format">HTTP message format</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n587"><a class="md-toc-inner" href="#http-request-message-format">HTTP request message format</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n599"><a class="md-toc-inner" href="#http-response-message-format">HTTP response message format</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n602"><a class="md-toc-inner" href="#http-response-status-codes">HTTP response status codes</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n607"><a class="md-toc-inner" href="#user-server-state-cookies">User-server state: cookies</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n612"><a class="md-toc-inner" href="#web-caching-proxy-server">Web caching (proxy server)</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n635"><a class="md-toc-inner" href="#23-email">2.3 Email</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n650"><a class="md-toc-inner" href="#smtp-rfc-2821">SMTP [RFC 2821]</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n659"><a class="md-toc-inner" href="#24-dns">2.4 DNS</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n679"><a class="md-toc-inner" href="#dns-name-space">DNS Name Space</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n684"><a class="md-toc-inner" href="#dns-hierarchy">DNS hierarchy</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n707"><a class="md-toc-inner" href="#local-dns-server">Local DNS server</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n719"><a class="md-toc-inner" href="#domain-name-resolution">Domain name resolution</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n721"><a class="md-toc-inner" href="#recursive-query">recursive query</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n728"><a class="md-toc-inner" href="#iterated-query">iterated query</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n752"><a class="md-toc-inner" href="#dns-caching-updating-records">DNS: caching, updating records</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n766"><a class="md-toc-inner" href="#dns-protocol-messages">DNS protocol, messages</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n770"><a class="md-toc-inner" href="#inserting-records-into-dnse">Inserting records into DNSe</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n774"><a class="md-toc-inner" href="#27-socket-programming-with-udp-and-tcp">2.7 socket programming with UDP and TCP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n807"><a class="md-toc-inner" href="#tcp-socket-programming">TCP socket programming</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n808"><a class="md-toc-inner" href="#tcp-server">TCP Server</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n834"><a class="md-toc-inner" href="#tcp-client">TCP Client</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n855"><a class="md-toc-inner" href="#cs-socket-interaction-tcp">C/S socket interaction: TCP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n858"><a class="md-toc-inner" href="#udp-socket-programming">UDP socket programming</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n869"><a class="md-toc-inner" href="#udp-server">UDP Server</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n898"><a class="md-toc-inner" href="#udp-client">UDP Client</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n920"><a class="md-toc-inner" href="#cs-socket-interaction-udp">C/S socket interaction: UDP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n923"><a class="md-toc-inner" href="#03-transport-layer-进程间的逻辑通信"><u>03. Transport Layer 进程间的逻辑通信</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n929"><a class="md-toc-inner" href="#31-transport-layer-services-and-protocols">3.1 transport-layer services and protocols</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n964"><a class="md-toc-inner" href="#32-multiplexing-and-demultiplexing">3.2 multiplexing and demultiplexing</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n975"><a class="md-toc-inner" href="#connectionless-demux">Connectionless demux</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n980"><a class="md-toc-inner" href="#connection-oriented-demux">Connection-oriented demux</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n985"><a class="md-toc-inner" href="#33-connectionless-transport-udp">3.3 connectionless transport: UDP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1015"><a class="md-toc-inner" href="#udp-checksum">UDP checksum</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1037"><a class="md-toc-inner" href="#34-principles-of-reliable-data-transfer">3.4 principles of reliable data transfer</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1055"><a class="md-toc-inner" href="#rdt-10-all-reliable">RDT 1.0 All reliable</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1061"><a class="md-toc-inner" href="#rdt-20-bit-errors">RDT 2.0 Bit errors</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1080"><a class="md-toc-inner" href="#rdt-21-acknak-corrupted">RDT 2.1 ACK/NAK corrupted</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1113"><a class="md-toc-inner" href="#rdt-22-nak-free-protocol">RDT 2.2: NAK-free protocol</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1123"><a class="md-toc-inner" href="#rdt-30-errors--loss">RDT 3.0 Errors &amp; loss</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1141"><a class="md-toc-inner" href="#rdt-30-stop-and-wait-operation">RDT 3.0 stop-and-wait operation </a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1157"><a class="md-toc-inner" href="#rdt-30-pipelined-protocols">RDT 3.0 Pipelined protocols </a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1174"><a class="md-toc-inner" href="#gbn-go-back-n">GBN (Go-Back-N)</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n1184"><a class="md-toc-inner" href="#sending-window">sending window</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n1195"><a class="md-toc-inner" href="#receiving-window">receiving window</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1209"><a class="md-toc-inner" href="#sr-selective-repeat">SR (Selective Repeat)</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1220"><a class="md-toc-inner" href="#pipelined-summary">Pipelined Summary</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1224"><a class="md-toc-inner" href="#35-connection-oriented-transport-tcp">3.5 connection-oriented transport: TCP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1228"><a class="md-toc-inner" href="#tcp-segment-structure">TCP segment structure</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1263"><a class="md-toc-inner" href="#tcp-sequence-number-ack">TCP sequence number, ACK</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1270"><a class="md-toc-inner" href="#tcp序号和确认号之间的关系">TCP序号和确认号之间的关系</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1297"><a class="md-toc-inner" href="#tcp-round-trip-time-timeout">TCP round trip time, timeout</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n1305"><a class="md-toc-inner" href="#estimatedrtt">EstimatedRTT</a></span><span role="listitem" class="md-toc-item md-toc-h6" data-ref="n1318"><a class="md-toc-inner" href="#devrtt">DevRTT</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1329"><a class="md-toc-inner" href="#tcp-reliable-data-transfer">TCP reliable data transfer</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1341"><a class="md-toc-inner" href="#tcp-retransmission-scenarios">TCP: retransmission scenarios</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1345"><a class="md-toc-inner" href="#tcp-fast-retransmit">TCP fast retransmit</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1350"><a class="md-toc-inner" href="#tcp-flow-control">TCP flow control</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1376"><a class="md-toc-inner" href="#36-tcp-congestion-control">3.6 TCP congestion control</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1386"><a class="md-toc-inner" href="#tcp-tahoe">TCP Tahoe</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1394"><a class="md-toc-inner" href="#tcp-reno">TCP Reno</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1418"><a class="md-toc-inner" href="#04-network-data-plane-端到端"><u>04. Network (Data Plane) 端到端</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1429"><a class="md-toc-inner" href="#41-overview-of-network-layer">4.1 Overview of network layer</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1431"><a class="md-toc-inner" href="#data-plane">data plane</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1446"><a class="md-toc-inner" href="#control-plane">control plane</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1464"><a class="md-toc-inner" href="#42-whats-inside-a-router">4.2 What’s inside a router </a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1468"><a class="md-toc-inner" href="#input-port-functions">Input port functions:</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1484"><a class="md-toc-inner" href="#input-port-queuing">Input port queuing</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1489"><a class="md-toc-inner" href="#switching-fabrics">Switching fabrics</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1501"><a class="md-toc-inner" href="#switching-via-memory">Switching via memory</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1516"><a class="md-toc-inner" href="#switching-via-a-bus">Switching via a bus</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1531"><a class="md-toc-inner" href="#switching-via-interconnection-network">Switching via interconnection network</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1541"><a class="md-toc-inner" href="#destination-based-forwarding-传统转发方式">destination-based forwarding (传统转发方式):</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1543"><a class="md-toc-inner" href="#longest-prefix-matching-最长前缀匹配">Longest prefix matching 最长前缀匹配</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1546"><a class="md-toc-inner" href="#output-ports--queueing">Output ports &amp; queueing</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1550"><a class="md-toc-inner" href="#43-ip-internet-protocol">4.3 IP: Internet Protocol</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1551"><a class="md-toc-inner" href="#ipv4-addressing">IPv4 addressing</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1560"><a class="md-toc-inner" href="#subnets">Subnets</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1572"><a class="md-toc-inner" href="#ip-datagram-format">IP Datagram format</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1575"><a class="md-toc-inner" href="#ip-分片和重组fragmentation--reassembly">IP 分片和重组(Fragmentation &amp; Reassembly)</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1591"><a class="md-toc-inner" href="#host如何获得一个ip地址">Host如何获得一个IP地址?</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1604"><a class="md-toc-inner" href="#dhcp-dynamic-host-configuration-protocol-udp">DHCP: Dynamic Host Configuration Protocol (UDP)</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1625"><a class="md-toc-inner" href="#4-important-dhcp-message-overview">4 important DHCP message overview:</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1636"><a class="md-toc-inner" href="#dhcp-不仅仅可以返回ip-addresses">DHCP: 不仅仅可以返回IP addresses</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1648"><a class="md-toc-inner" href="#一个isp如何获得一个地址块">一个ISP如何获得一个地址块?</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1658"><a class="md-toc-inner" href="#05-network-control-plane"><u>05. Network (Control Plane)</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1662"><a class="md-toc-inner" href="#51-intro-control-plane">5.1 Intro: control plane</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1670"><a class="md-toc-inner" href="#52-routing-protocols">5.2 routing protocols</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1679"><a class="md-toc-inner" href="#routing-algorithm-classification">Routing algorithm classification</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1693"><a class="md-toc-inner" href="#521-link-state-dijkstra">5.2.1 Link state (Dijkstra)</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1718"><a class="md-toc-inner" href="#examples-01"><em>Examples 01</em></a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1720"><a class="md-toc-inner" href="#examples-02"><em>Examples 02</em></a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1722"><a class="md-toc-inner" href="#examples-03"><em>Examples 03</em></a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1725"><a class="md-toc-inner" href="#examples-04"><em>Examples 04</em></a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1822"><a class="md-toc-inner" href="#522-distance-vector-bellman-ford-equation">5.2.2 Distance vector (Bellman-Ford equation)</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n1832"><a class="md-toc-inner" href="#distance-vector-link-cost-changes">Distance vector: link cost changes</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1849"><a class="md-toc-inner" href="#523-link-state--distance-vector-算法的比较">5.2.3 Link State &amp; Distance Vector 算法的比较</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1859"><a class="md-toc-inner" href="#53-intra-as-routing">5.3 intra-AS routing</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1876"><a class="md-toc-inner" href="#internet-approach-to-scalable-routing">Internet approach to scalable routing</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1884"><a class="md-toc-inner" href="#54-three-intra-domain-routing-protocols">5.4 Three intra domain routing protocols</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1885"><a class="md-toc-inner" href="#rip">RIP</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1898"><a class="md-toc-inner" href="#ospf-ls">OSPF (LS)</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1920"><a class="md-toc-inner" href="#igrp">IGRP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1929"><a class="md-toc-inner" href="#54-routing-among-the-isps-bgp-dv">5.4 routing among the ISPs: BGP (DV)</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1935"><a class="md-toc-inner" href="#06-link-layer-and-lans-点到点传输层功能"><u>06. Link Layer and LANs 点到点传输层功能</u></a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1956"><a class="md-toc-inner" href="#61-services">6.1 services</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1989"><a class="md-toc-inner" href="#network-interface-card-网卡">Network interface card 网卡</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1998"><a class="md-toc-inner" href="#62-error-detection-correction">6.2 error detection, correction</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n1999"><a class="md-toc-inner" href="#621-error-detection-错误检测">6.2.1 Error detection 错误检测</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2008"><a class="md-toc-inner" href="#622-parity-checking-奇偶校验">6.2.2 Parity checking 奇偶校验</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2011"><a class="md-toc-inner" href="#623-internet-checksum-因特网检验和">6.2.3 Internet checksum 因特网检验和</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2014"><a class="md-toc-inner" href="#624-cyclic-redundancy-check-crc-循环冗余校验">6.2.4 Cyclic Redundancy Check (CRC) 循环冗余校验</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n2027"><a class="md-toc-inner" href="#63-multiple-access-protocols">6.3 multiple access protocols</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2059"><a class="md-toc-inner" href="#631-mac-protocols">6.3.1 MAC protocols</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2082"><a class="md-toc-inner" href="#632-channel-partitioning">6.3.2 channel partitioning</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n2083"><a class="md-toc-inner" href="#channel-partitioning-mac-protocols-tdma">Channel partitioning MAC protocols: TDMA</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n2096"><a class="md-toc-inner" href="#channel-partitioning-mac-protocols-fdma">Channel partitioning MAC protocols: FDMA</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2107"><a class="md-toc-inner" href="#633-random-access-protocols">6.3.3 Random access protocols</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n2131"><a class="md-toc-inner" href="#slotted-aloha">Slotted ALOHA</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n2138"><a class="md-toc-inner" href="#pure-unslotted-aloha-效率比时隙aloha更差">Pure (unslotted) ALOHA 效率比时隙ALOHA更差！</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n2153"><a class="md-toc-inner" href="#634-csma-carrier-sense-multiple-access-礼貌的对话人">6.3.4 CSMA (carrier sense multiple access) 礼貌的对话人</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n2165"><a class="md-toc-inner" href="#64-lans">6.4 LANs</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n2169"><a class="md-toc-inner" href="#65-a-day-in-the-life-of-a-web-request">6.5 a day in the life of a web request</a></span></p></div><h2 id='00-introduction'><u><span>00. Introduction:</span></u></h2><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-11%2017.10.20.png" referrerpolicy="no-referrer" alt="截屏2023-01-11 17.10.20"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-11%2017.09.57.png" referrerpolicy="no-referrer" alt="截屏2023-01-11 17.09.57"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-11%2017.09.32.png" referrerpolicy="no-referrer" alt="截屏2023-01-11 17.09.32"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id='01-computer-networks-and-the-internet'><u><span>01. Computer Networks and the Internet</span></u></h2><h3 id='11-internet'><span>1.1 Internet</span></h3><p><span>在本书中，我们使用一种特定的计算机网络，即公共因特网，作为讨论计算机网络及其协议的主要载体 。 </span></p><p><span>互联网 (Internet)，由计算机网络互联而成（即“网络的网络”）的庞大的系统，是以 TCP/IP 协议为主的一簇协议支撑工作的网络。</span></p><ul><li><p><span>构成描述：</span><strong><span>Internet = network edge + access nekwork + network core</span></strong></p></li><li><p><span>服务描述：互联网是为 </span><strong><span>分布式的应用进程</span></strong><span> 提供</span><strong><span>通讯服务</span></strong><span>的 </span><strong><span>基础设施</span></strong><span>，包括应用层以下的 </span><strong><span>protocol</span></strong><span>。互联网通过套接字接口 (API) 为进程提供服务，规定了接入网络核心的端系统数据交付的方式。分布式应用（distributed application）指的是应用程序分布在不同计算机上，通过网络来共同完成一项任务的工作方式。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-14%2013.59.00.png" alt="截屏2023-01-14 13.59.00" style="zoom:33%;" /></p></li></ul><p>&nbsp;</p><h4 id='nuts-and-bolts-view'><span>&quot;nuts and bolts&quot; view</span></h4><p><span>从因特网的</span><strong><span>具体构成（结构上）来看</span></strong><span>，Internet 就是一堆的网络，通过(几十亿)网络互联设备连在一起的一个巨型网络。其中有</span></p><ul><li><p><u><strong><span>Network edge:</span></strong><span> 和互联网连接的设备，称为:</span></u><span> </span><strong><u><span>hosts 主机 = end systems 端系统</span></u><span> (eg. iPad, iPhone, PC, MacBook) 来运行网络应用程序</span></strong></p></li><li><p><u><strong><span>Access networks (physical media):</span></strong><span> 就是有线或者无线通信链路</span></u><span>，可以把边缘接入到网络核心, 可以将报文发给另外一个主机。</span><strong><span>end systems</span></strong><span> 通过 </span><strong><span>communication links (通信链路)</span></strong><span> 和 </span><strong><span>packet switches (分组交换机)</span></strong><span> 连接在一起，</span><u><strong><span>link 的 transmission rate = bandwidth 带宽(bit /s or bps)</span></strong></u><span>，发送数据形成的信息包称为 </span><strong><span>packet (分组)</span></strong></p><ul><li><strong><span>packet switches 分组交换机(forward packets 转发设备):</span></strong><span>  作用是来了一个数据从哪个地方把它转走，不同的网络层工作的层次/支撑它运行的协议不一样， 根据</span><strong><span>不同的协议</span></strong><span>可以把它分成</span><strong><span>链路层的交换机、网络层的路由器、防火墙等等</span></strong><span>。eg. </span><u><span>routers 路由器 and switches 交换机</span></u></li><li><strong><span>communication links (通信链路):</span></strong><span> eg. fiber 光纤, copper 同轴电缆, radio 无线电, satellite 卫星</span></li><li><span>当一台端系统要向另 一 台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节 。 由此形成的信息包用计算机网络的术语来说称为 </span><strong><span>packet (分组)</span></strong><span>。 这些分组通过网络发送到目的端系统，在那里被装配成初始数据 。</span></li></ul></li><li><p><u><strong><span>network core 属于基础设施:</span></strong><span> 就是</span><strong><span>一堆互相连接的路由器(mesh of interconnected routers)</span></strong></u><span>，网络核心能够把所有的东西发给我所需要的目标主机，网络核心连接着所有端系统，从而我可以跟所有的端系统通信。作用：数据交换</span></p></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2016.30.32.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 16.30.32"></p><h4 id='service-view'><span>Service view</span></h4><p><strong><span>从服务角度</span></strong><span>来看: 互联网是 </span><strong><span>分布式的应用</span></strong><span> 以及 </span><strong><span>为分布式应用提供通讯的这个基础设施</span></strong></p><ul><li><span>Distributed application 是网络存在的理由，</span><strong><span>为 分布式应用（distributed application）提供通讯服务的基础设施</span></strong><span>(infrastructure, eg. PC)</span></li><li><span>通信基础设施为apps提供编程接口API (通信服务)，使设备之间可以进行连接。eg. 允许发送和接收应用程序 &quot;连接&quot; 到互联网的接口(API)</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2015.23.13.png" alt="截屏2023-01-12 15.23.13" style="zoom:35%;" /></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2020.44.10.png" alt="截屏2023-01-13 20.44.10" style="zoom:45%;" /></p><h3 id='12-protocol'><span>1.2 Protocol</span></h3><ul><li><strong><span>protocol 协议(标准):</span></strong><span> Internet 中所有的通信行为都受协议制约。对等的实体在通讯过程当中，应该遵守的规则集合，是一个标准和规范。协议定义了在两个或多 个通信实体之间交换的 </span><strong><span>format, order of messages sent (报文格式和次序)</span></strong><span>，以及 在报文传输和/或接收或 其他事件方面所采取的 </span><strong><span>actions (动作)</span></strong></li><li><span>协议控制发送、接收消息 eg. TCP, IP, HTTP, FTP, PPP, Skype, 802.11</span></li></ul><p><span>例：一个web的浏览器运行在这个PC机上，他们首先要建立起一个TCP的连接， 然后我按照 http 的协议规范，向对方发出请求。发出请求之后，就是把这个报文封装在 http 请求的报文格式当中，按照TCP的规范发给对方。对方建立起TCP的连接之后，就能够收到这个报文，然后根据协议解析这个报文，读取对方请求的信息/动作，捡取消息后把该消息封装成http相应的报文格式发送给对方。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2015.39.04.png" alt="截屏2023-01-12 15.39.04" style="zoom:35%;" /></p><p>&nbsp;</p><h3 id='13-network-structure'><span>1.3 Network structure</span></h3><center>
  <img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2016.30.32.png" alt="截屏2023-01-12 16.30.32" style="zoom:80%;">
  <br> 
  Internet = network edge + access nekwork + network core
</center><p>&nbsp;</p><h4 id='network-edge'><span>Network edge</span></h4><p><strong><span>network edge 网络边缘，不属于基础设施:</span></strong><span> hosts (clients and servers) -&gt; host(客户端, 手机, 电脑)可以跑应用(游戏，电子商务) -&gt; sends/receives packets of data</span></p><p><span>主机发送功能：获取应用消息，</span><strong><span>分成 smaller chunks (小的数据块)</span></strong><span>，称为 </span><strong><span>packets</span></strong><span>，</span><strong><span>长度为 L bits</span></strong><span>。以 </span><strong><span>transmission rate R</span></strong><span> 将数据包传输到接入网络。</span><strong><span>link transmission rate = link bandwidth = link capacity</span></strong></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2016.51.46.png" alt="截屏2023-01-12 16.51.46" style="zoom:35%;" /></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2016.54.31.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 16.54.31"></p><p>&nbsp;</p><h4 id='access-networks--physical-media'><span>Access networks &amp; physical media</span></h4><ul><li><strong><span>access networks (physical media) 接入网络和物理媒体, 属于基础设施:</span></strong><span> wired, wireless communication links. 就是把边缘接入到网络核心, 可以将报文发给另外一个主机。</span></li><li><span>接入有一个非常重要的指标：</span><strong><span>bandwidth (data rate) of access network: bps (bits per second), Kbps, Mbps, Gbps</span></strong></li><li><strong><span>将端系统和边缘路由器连接(connect end systems to edge router)</span></strong><span> 有几种接入方式：住宅接入网络（图片左下角）、单位接入网络 (学校、公司)、无线接入网络（图片左上角）。有独享和共享接入方式。例：那我们现在通过这个中国电信的这个光纤接入到电信的这个网络交换设备，是独享。在公司/学校里，如果使用的是有限接入公司的带宽，和几百个电脑共享这个带宽，凌晨访问可能可以有100Mps，但是平常下午5、6点就可能只有3-4Mps</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2014.59.38.png" alt="截屏2023-01-13 14.59.38" style="zoom:25%;" /></p><p><span>在 </span><strong><span>Access networks &amp; physical media</span></strong><span> 中有几种 </span><strong><span>将端系统和边缘路由器连接(connect end systems to edge router)</span></strong><span> 的连接方式</span></p><p>&nbsp;</p><h5 id='住宅接入网络-dsl--cable'><span>住宅接入网络 DSL &amp; cable</span></h5><p><span>宽带住宅接人有两种最流行的类型是：</span><strong><span>数字用户线 (Digital Subscriber Line, DSL)</span></strong><span> 和 </span><strong><span>cable</span></strong><span>。住户通常从提供本地电话接入的本地电话公司处获得 DSL 因特网接入 。 因此，当使用DSL时，用户的本地电话公司也是它的lSPc </span></p><p>&nbsp;</p><p><span>在此之前，我们先了解一下 modem(调制解调器) 和 router(路由器) 区别:</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.28.37.png" alt="截屏2023-01-13 21.28.37" style="zoom: 25%;" /></p><p><span>modem 能將互联网带入您的家庭/企业，建立并维护与 ISP 的专用 link，以至于我们才可以访问互联网。</span></p><p><span>之所以我们需要使用 modem 的原因是因为：计算机和互联网上使用的是两种不同类型的信号（计算机是数字信号且只读取数字信号，互联网上的信号是模拟信号且只读取模拟信号。A computer only reads digital signals. The internet only reads analog signals.）</span></p><p><span>当模拟信号从互联网上传入我们家时，modem 就会将输入的 analog signals 解调为 digital signals，以便计算机能够理解。反之，modem 也可以将来自计算机的输出的 digital signals 解调为 analog signals。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.32.48.png" alt="截屏2023-01-13 21.32.48" style="zoom:43%;" /></p><p>&nbsp;</p><p><span>所以从技术上来讲，其实并不需要 router 如果只想要一台设备访问 internet，但是如果有多台机器就需要使用 router 了。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.49.34.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 21.49.34"></p><p>&nbsp;</p><p><span>modem 分为 DSL modem 和 cable modem：</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.42.05.png" alt="截屏2023-01-13 21.42.05" style="zoom:43%;" /></p><p>&nbsp;</p><p><span>router 可以通过网线连接有限设备，通过 Wi-Fi 连接无线信号。下面这附图演示了，多个不同的网络是如何连接到互联网的。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.46.14.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 21.46.14"></p><p>&nbsp;</p><p><span>一般情况下，router 内部都有一个 switch交换机来连接有限设备，假如 switch 有3条接口，那我就可以连接3个有限设备。但是如果我有更多的设备，需要有线连接，那么我就需要额外的 swith：</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.48.08.png" alt="截屏2023-01-13 21.48.08" style="zoom:40%;" /></p><p><span>为什么20M宽带，我最大下载速度只能到2.5M? </span></p><p><span>宽带太小一般用的单位是20Mb，而我们平时一般是用MB作单位的。他们之间的换算关系是：1Byte=8bit。</span></p><p>&nbsp;</p><h6 id='access-network-digital-subscriber-line-dsl'><span>Access network: Digital Subscriber Line (DSL)</span></h6><ul><li><span>是使用调制解调方式，直接用电话线和互联网连接，但是带宽不是很大。use </span><strong><span>existing telephone line</span></strong><span> to central office </span><strong><span>DSLAM (DSL接入共享器)</span></strong></li><li><span>DSL线路上的数据被传到互联网，DSL线路上的语音被传到电话网，DSL有专用的连接到中央办公室的通道</span></li><li><span>&lt; 2.5 Mbps upstream transmission rate (typically &lt; 1 Mbps) 上行/上传速度</span></li><li><span>&lt; 24 Mbps downstream transmission rate (typically &lt; 10 Mbps) 下行/下载速度</span></li><li><span>因为这些上行速率和下行 速率是不同的，所以这种接入被称为是不对称的。因为他的下载速度比上传速度快得多</span></li><li><span>数据在专享线路的不同频段传输。现有电话线: 0~4kHz为电话; 4~50kHz 为上行数据; 50kHz~IMHz 为下行数据。</span></li></ul><p><span>家庭的 DSL modem 得到 数字数据 后将其转换为 高频音，以通过电话线传输给 本地中心局CO(central office); 来自许多家庭的模拟信号在 DSLAM 处被转换回数字形式 。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2021.00.42.png" alt="截屏2023-01-13 21.00.42" style="zoom:45%;" /></p><p><span>虽然使用 DSL 比cable modem慢，但并不用像有线连接那样与邻居共享宽带。每个使用DS L的用户都有自己的专用连接，而不是共享线路，而且更加便宜，因为它使用的是几乎无处不在的普通电话线。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2022.23.41.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 22.23.41"></p><p>&nbsp;</p><h6 id='access-network-cable-network'><span>Access network: cable network</span></h6><ul><li><span>DSL 利用电话公司现有的本地电话基础设施，而</span><strong><span>电缆因特网接入 (cable Internet access )</span></strong><span> 通常由向用户提供的</span><strong><span>有线电视的同一提供商提供</span></strong><span>，也就是说用户可以利用有线电视的 cable 来上网</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2022.28.16.png" alt="截屏2023-01-13 22.28.16" style="zoom: 30%;" /></p><ul><li><span>但是有一个缺点就是用户需要和他附近的其他家庭共享宽带。住宅从提供有线电视的公司获得了电缆因特网接入。如图所示，光缆将电缆头端连接到地区枢纽，从这里使用传统的同轴电缆到达各家各户和公寓。每个地区枢纽通常支持 500 -5000 个家庭。因为在这个系统中应用了光纤和同轴电缆，所以它经常被称为</span><strong><span>混合光纤同轴 (Hybrid Fiber Coax, HFC) 系统。</span></strong><span>所以在高峰期网速就会比较慢。</span></li><li><strong><span>Asymmetric (非对称):</span></strong><span> 最高 </span><strong><span>30 Mbps 的下行传输速率 (downstream transmission rate)</span></strong><span> 和 </span><strong><span>2 Mbps 上行传输速率 (upstream transmission rate)</span></strong><span>。因为这些上行速率和下行 速率是不同的，所以这种接入被称为是不对称的 。 </span></li><li><span>线缆和光纤网络将个家庭用户接入到 ISP 路由器，各用户共享到线缆头端的接入网络。与DSL不同, DSL每个用户一个专用线路到CO(central office)。电缆因特网接入需要特殊的调制解调器，这种调制解调器称为电缆调制解调器 (cable modem) 。 </span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2015.14.03.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 15.14.03"></p><p><span>有线电视信号线缆双向改造，大家是共享的带宽</span>
<span>FDM: 在不同频段传输不同信道的数据，数字电视和上网数据(上下行)</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2015.14.37.png" alt="截屏2023-01-13 15.14.37" style="zoom:40%;" /></p><figure><table><thead><tr><th><strong><span>接入类型</span></strong></th><th><strong><span>互联网服务提供商</span></strong></th><th><strong><span>依托的固有基础设施</span></strong></th><th><strong><span>使用的技术</span></strong></th></tr></thead><tbody><tr><td><span>数字用户线 (Digital Subscriber Line, DSL)</span></td><td><span>本地电话公司</span></td><td><span>由双绞铜线组成的电话线网络</span></td><td><span>数字用户线复用器 (DSLAM)</span></td></tr><tr><td><span>电缆因特网接入 (cable Internet access)</span></td><td><span>有线电视公司</span></td><td><span>由光线和同轴电缆组成的混合光线同轴系统</span></td><td><span>电缆调制解调器端接系统 (Cable Modem Termination System, CMTS)</span></td></tr><tr><td><span>光纤到户 (fiber to the home, FTTH)</span></td><td><span>本地中心局</span></td><td><span>建立一条直接入户的光纤路径</span></td><td><span>光线线路端接器 (Optical Line Terminator, OLT)</span></td></tr></tbody></table></figure><p>&nbsp;</p><h5 id='企业接入网络-ethernet'><span>企业接入网络 (Ethernet)</span></h5><p><strong><span>Enterprise access networks (Ethernet) 企业接入网(以太网):</span></strong><span> 经常被企业或者大学等机构采用，公司、大学校园和企业等单位的终端用户使用双绞铜线，通过局域网 (LAN) 的方式接入以太网 (Ethernet) 交换机，连接边缘路由器。10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率。现在，端系统经常直接接到以太网络交换机上。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2022.51.37.png" alt="截屏2023-01-13 22.51.37" style="zoom:40%;" /></p><p>&nbsp;</p><h5 id='无线接入网络-wireless'><span>无线接入网络 Wireless</span></h5><p><strong><span>Wireless access networks (无线接入网络) 有两种:</span></strong><span> </span></p><ul><li><strong><span>wireless LANs (无线局域网):</span></strong><span> 各 wireless end systems 共享 wireless router (Wi-Fi), wireless LANs = WLAN = Wi-Fi</span></li><li><strong><span>wide-area wireless access (广域无线接入):</span></strong><span> 通过 </span><strong><span>base station(基站)</span></strong><span> 或者叫 </span><strong><span>access point(接入点)</span></strong></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2022.54.37.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 22.54.37"></p><h5 id='physical-media-物理媒体'><strong><span>Physical media (物理媒体)</span></strong><span> </span></h5><ul><li><strong><span>signal:</span></strong><span> propagates between transmitter/receiver pairs</span></li><li><strong><span>physical link:</span></strong><span> lies between transmitter &amp; receiver</span></li><li><strong><span>guided media:</span></strong><span> 信号沿着固体媒介被导引: copper, coax, fiber</span></li><li><strong><span>unguided media:</span></strong><span> 开放的空间传输电磁波或者光信号，在电磁或者光信号中承 载数字数据 e.g., radio</span></li><li><strong><span>twisted pair (TP):</span></strong><span> 两根绝缘铜导线拧合(two insulated copper wires). Category 5: 100 Mbps, 1 Gbps Ethernet. Category 6: 10Gbps</span></li><li><strong><span>coaxial cable:</span></strong><span> two concentric copper conductors, bidirectional. Broadband: multiple channels on cable, HFC</span></li><li><strong><span>fiber optical cable:</span></strong><span> glass fiber carrying light pulses. high-speed operation: high-speed point-to-point transmission (e.g., 10’s-100’s Gbps transmission rate). low error rate: repeaters spaced far apart, immune to electromagnetic noise</span></li></ul><p>&nbsp;</p><h4 id='network-core'><span>Network core</span></h4><ul><li><span>目的/作用：数据交换</span></li><li><span>实现的方式有两种：packet switching 分组交换 &amp; circuit switching 电路交换</span></li></ul><p><strong><span>network core 属于基础设施:</span></strong><span> 就是</span><strong><span>一堆互相连接的路由器(mesh of interconnected routers)</span></strong><span>，网络核心能够把所有的东西发给我所需要的目标主机，网络核心连接着所有端系统，从而我可以跟所有的端系统通信。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2016.56.27.png" alt="截屏2023-01-12 16.56.27" style="zoom:30%;" /></p><h5 id='packet-switching-分组交换'><span>packet switching 分组交换</span></h5><ul><li><p><strong><span>store-and-forward (存储-转发):</span></strong><span> 网络带宽资源不再分分为一个个片，传输时使用全部带宽</span></p><ul><li><span>将要传送的 messages/data 分成一个个单位 packet(分组)</span></li><li><span>将packet从一个路由器传到相邻路由器(hop)，一段段最终从源端传到目标端，期间可能通过许多不同的路由器，就会不断发生存储和转发。在转发之前，节点必须收到整个 packet，延迟比 circuit switching 要大，排队时间长。但是</span><strong><span>换取了资源共享性</span></strong></li><li><span>each packet 采用链路的最大传输能力(带宽)</span></li><li><span>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</span></li></ul><p><strong><u><span>在一个速率为R bps 的 link，一个长度为L-bit packet 以 R bps 的速率传输到 link 的存储转发延时需要 L/R seconds</span></u></strong></p><p><span>Example: L = 7.5 Mbits，R = 1.5 Mbps</span></p><p><span>one-hop transmission delay(每次存储的延迟) = 5 s。注意接收也需要存储的延迟，图中就应该是有10s。</span></p><p><span>end-end delay = 2L/R (assuming zero propagation delay)</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.28.55.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 17.28.55"></p></li></ul><p>&nbsp;</p><ul><li><p><strong><span>queueing delay, loss (排队延迟和丢失):</span></strong><span> 如果 arrival rate (in bits) to link &gt; transmission rate: packets 将在路由器上排队，等待在link上传输。如果 memory (buffer) 填满/用完了，packets 可能会 </span><strong><span>被抛弃/丢失 dropped (lost)</span></strong><span>。 可以说这是 </span><u><span>packet switching 分组交换</span></u><span> 为了获得共享性所必须要付的代价。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.51.38.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 17.51.38"></p></li></ul><p>&nbsp;</p><ul><li><p><strong><span>Two key network-core functions:</span></strong></p><ul><li><strong><span>routing (路由)</span></strong><span>: 决定分组采用的源到目标的路径</span></li><li><strong><span>forwarding (转发)</span></strong><span>: 将分组从路由器的输入链路转移到输出链路</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.58.14.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 17.58.14"></p></li></ul><p>&nbsp;</p><h5 id='circuit-switching-电路交换'><span>circuit switching 电路交换</span></h5><p><span>端到端的资源被分配给从源端 到目标端的呼叫 “call”:</span></p><ul><li><span>图中 </span><u><span>each link has 4 circuits: call gets 2nd circuit in top link and 1st circuit in right link</span></u></li><li><span>是 </span><strong><span>独享资源(dedicated resources): </span></strong><span>no sharing，每个呼叫一旦建立起来就能够保证性能</span></li><li><span>如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing). 就像两个人打电话，但是却沉默不语，电信公司仍然要收钱</span></li><li><span>通常被 traditional telephone networks 采用</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.09.06.png" alt="截屏2023-01-12 17.09.06" style="zoom:25%;" /></p><p><span>In circuit switching，网络带宽资源会被分为一个个片(piece)，网络资源(如带宽)被分成片的两种方式：</span></p><ul><li><span>频分(Frequency-Division Multiplexing): 交换接电和交换节点之间的链路带宽比较宽， 两个host在通讯之前在每一条链路上找到空闲的一片</span></li><li><span>时分(Time-Division Multiplexing): 划分时间片的方式。每个周期的第一片，分给第一个用户使用; 每个周期的第二片，分给第二个用户使用...</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.19.57.png" alt="截屏2023-01-12 17.19.57" style="zoom:35%;" /></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2017.25.55.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 17.25.55"></p><p>&nbsp;</p><h5 id='packet-switching-vs-circuit-switching'><span>Packet switching vs circuit switching</span></h5><p><span>同样的网络资源，Packet switching 允许更多用户使用网络（共享性，按需分配），避免了 circuit switching 占线却并没有传输数据的浪费资源现象。适合于对突发式数据传输(great for bursty data)。但是过度使用会造成网络拥塞:分组延时和丢失，对可靠地数据传输需要协议来约束: 拥塞控制。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.28.53.png" alt="截屏2023-01-12 18.28.53" style="zoom:50%;" /></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.31.24.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 18.31.24"></p><p>&nbsp;</p><h3 id='14-internet-structure-and-isp'><span>1.4 Internet structure and ISP</span></h3><h4 id='internet-structure'><span>Internet structure</span></h4><ul><li><span>互联网结构：网络中的网络 network of networks，网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</span></li><li><strong><span>ISPs (Internet Service Providers):</span></strong><span> 互联网服务提供商，可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</span></li><li><strong><span>End systems (端系统)</span></strong><span> 通过接入</span><strong><span>ISPs</span></strong><span> 连接到互联网 (eg. 住宅，公司和大学的ISPs)</span></li><li><span>接入ISPs相应的必须是互联的，因此任何2个端系统可相互发送分组到对方</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.14.26.png" alt="截屏2023-01-12 23.14.26" style="zoom:43%;" /></p><p>&nbsp;</p><p><span>问题: 给定数百万接入ISPs，如何将它们互联到一起。</span></p><p><span>如果将每个接入ISP直接连接到彼此不能扩展(scale)，需要O(N2)连接。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.53.33.png" alt="截屏2023-01-12 18.53.33" style="zoom:30%;" /></p><p><span>所以我们可以将每个接入ISP都连接到全局ISP(全局范围内覆盖)：客户ISPs和提供者ISPs有经济合约，这样当然好，但是如果世界上不可能只有一个ISP网络，由于有利可图，肯定会有能做出ISP技术的人出来跟他一起竞争。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.53.47.png" alt="截屏2023-01-12 18.53.47" style="zoom:30%;" /></p><p><span>但是，如果全局ISP是可行的业务，那会有竞争者有利可图，一定会有竞争：</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.54.31.png" alt="截屏2023-01-12 18.54.31" style="zoom:30%;" /></p><p><span>竞争: 但如果全局ISP是有利可为的业务，那会有竞争者</span></p><p><span>合作: 通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系。图中ISP A、B、C大家都接入了IXP网络，其中 IXP 就叫 </span><strong><span>Internet exchange point</span></strong></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2018.58.19.png" alt="截屏2023-01-12 18.58.19" style="zoom:30%;" /></p><p><strong><span>Internet Content Providers (内容提供商网络):</span></strong><span> 可能会构建它们自己的网络，将它们的服务、内容更 加靠近端用户，向用户提供更好的服务。而且不用给用其他ISP网络，连接若干local ISP和各级(包括一层)ISP,更加靠近用户。搭建自己的网络就不要给其他ISP网络的运营商交钱，减少运营成本。e.g. Google, Microsoft, Akamai</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2019.00.38.png" alt="截屏2023-01-12 19.00.38" style="zoom:30%;" /></p><p>&nbsp;</p><h4 id='isp的三个层次和连接'><span>ISP的三个层次和连接</span></h4><p><span>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</span></p><ul><li><strong><span>中心：第一层ISP（如UUNet, BBN/Genuity, Sprint, AT&amp;T）</span></strong><span>国家/国际覆盖，速率极高。直接与其他第一层ISP相连。与大量的第二层ISP和其他客户网络相连</span></li><li><strong><span>第二层ISP</span></strong><span>: 更小些的ISP </span><strong><span>(regional ISP)</span></strong><span>，与一个或多个第一层ISPs，也可能与其他第二层ISP</span></li><li><strong><span>第三层ISP与其他本地ISP</span></strong><span>，</span><strong><span>local ISP, access net</span></strong><span> (与端系统最近)</span></li><li><span>POP: 高层ISP面向客户网络的接入点，涉及费用结算。如一个低层ISP接入多个高层ISP，多宿(multi home)</span></li><li><span>对等接入: 2个ISP对等互接，不涉及费用结算</span></li><li><span>IXP:多个对等ISP互联互通之处，通常不涉及费用结算。对等接入</span></li><li><span>ICP自己部署专用网络，同时和各级ISP连接</span></li></ul><p><span>在网络的最中心，一些为数不多的充分连接的大范围网络(分布广、节点有限、 但是之间有着多重连接)</span></p><ul><li><span>&quot;tier-1&quot; commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), national &amp; international coverage</span></li><li><span>content provider network (e.g., Google): 将它们的数据中心接入ISP，方便周边用户的访问;通常私有网络之间用专网绕过第一层ISP和区域ISPs</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2019.08.47.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 19.08.47"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2019.16.35.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 19.16.35"></p><p>&nbsp;</p><h3 id='15-performance-loss-delay-throughput'><span>1.5 Performance: loss, delay, throughput</span></h3><p><span>网络核心采用的是 packet switching, 所以可能会产生 loss and 四个delay。</span></p><h4 id='loss-and-delay'><span>loss and delay</span></h4><p><strong><span>Delay 产生的原因:</span></strong><span> 在路由器当中，每条 link 都对应相应的队列，如果有一个packet需要传输，他就会先通过查路由表决定通过哪条队列，通过其 link 往外走。如果这条 link 上，当前没有 packet 在传输，就直接可以传。但是如果有其他的 packet 在传输，那就必须排在队列当中。 只有排到队头，才可以被传输。</span></p><p><strong><span>Loss 产生的原因:</span></strong><span> 队列是有限的，如果来了一个 packet 加入这个队列，但是队列已经满了，这是 packet 就会被丢弃。丢失的 packet 可能会被前一个节点或源端系统重传，或根本不重传</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.30.21.png" alt="截屏2023-01-12 23.30.21" style="zoom:35%;" /></p><p>&nbsp;</p><h4 id='four-sources-of-packet-delay'><span>Four sources of packet delay</span></h4><p><span>节点延时 nodal delay 可以分为4个部分：</span></p><figure><table><thead><tr><th><span>名称</span></th><th><span>描述</span></th><th><span>计算公式</span></th></tr></thead><tbody><tr><td><strong><span>nodal processing (节点处理延时)</span></strong></td><td><span>数据在路由器中处理需求的时间</span></td><td><span>NA</span></td></tr><tr><td><strong><span>queueing delay (排队延时)</span></strong></td><td><span>数据在路由器前等待前面数据处理的时间</span></td><td><span>L: packet length (bits), R: link bandwidth (bps),</span><br><span>a: average packet arrival rate</span><br><span>traffic intensity (流量强度) = La/R</span><br><span>La/R = 0: 平均排队延时很小</span><br><span>La/R -&gt; 1: 延时变得很大</span><br><span>La/R &gt; 1: 平均排队延时将趋向无穷大</span><br><span>所以设计系统时流量强度不能大于1</span></td></tr><tr><td><strong><span>transmission delay (传输延时)</span></strong></td><td><span>数据在信道上传播所花费的时间</span></td><td><span>L/R </span><br><span>L: packet length (bits), R: link bandwidth (bps)</span></td></tr><tr><td><strong><span>propagation delay (传播延时)</span></strong></td><td><span>数据从主机到信道上所用的时间</span></td><td><span>d/s</span><br><span>d = link length, s = 在媒体上的传播速度</span></td></tr></tbody></table></figure><ul><li><strong><span>nodal processing (节点处理延时):</span></strong><span> 检查 bit级差错，检查 packet(首部) 有没有出错和决定将分组导向何处的处理消耗的时间</span></li><li><strong><span>queueing delay (排队延时):</span></strong><span> 在输出链路上等待传输的时间，依赖于路由器的拥塞程度。</span></li><li><strong><span>transmission delay (传输延时):</span></strong><span> R=链路带宽(bps)，L=分组长度(bits)，将分组发送到链路上的时间 (传输延时) = L/R，存储转发延时</span></li><li><strong><span>propagation delay (传播延时): </span></strong><span>d = 物理链路的长度，s = 在媒体上的传播速度 (~3x10^8 m/sec)，传播延时 = d/s</span></li></ul><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2020.43.13.png" alt="截屏2023-01-12 20.43.13" style="zoom:33%;" /></p><center>
  <img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2020.46.17.png" alt="截屏2023-01-12 20.46.17" style="zoom:18%;">
  <img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2020.46.28.png" alt="截屏2023-01-12 20.46.28" style="zoom:18%;"></center><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2015.44.23.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 15.44.23"></p><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2015.44.57.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 15.44.57"></p><p>&nbsp;</p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.25.39.png" alt="截屏2023-01-12 23.25.39" style="zoom:30%;" /></p><p>&nbsp;</p><h4 id='throughput-吞吐量'><span>throughput 吞吐量</span></h4><ul><li><p><strong><span>单位时间内，从原主机向目标主机发出去有效的比特的数量</span></strong><span>，在源端和目标端之间传输的速率 (bits/time unit), rate (bits/time unit) at which bits transferred between sender/receiver (end-to-end)</span></p><ul><li><strong><span>instantaneous (瞬间吞吐量):</span></strong><span> 在</span><strong><span>一个时间点</span></strong><span>的速率</span></li><li><strong><span>average (平均吞吐量):</span></strong><span> 在一个</span><strong><span>长时间内平均值</span></strong></li></ul></li></ul><p><strong><span>server (服务器)</span></strong><span> 发送 bits 到管道, 他的有效吞吐量取决于细的管道 (取决于第 I 个管道)。吞吐量 = min{Rs,Rc}</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.33.59.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 23.33.59"></p><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2016.07.17.png" alt="Screenshot 2023-02-07 at 16.07.17" style="zoom:53%;" /></p><p><strong><span>bottleneck link (瓶颈链路):</span></strong><span> 端到端路径上，限制端到端吞吐的 link (最细的link就是他的 bottleneck link 瓶颈链路)</span></p><p><span>端到端平均吞吐=min{R1，R2,...,Rn}</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.42.16.png" referrerpolicy="no-referrer" alt="截屏2023-01-12 23.42.16"></p><p>&nbsp;</p><p><span>在互联网场景中，我们一般都是分组交换，按需使用，这条link是共用的，n 个设备，那么每个设备的带宽将是 1/n，每个设备所获得的带宽是平均的，取决于 n 个设备。假设有10个设备，那么每个设备的带宽将是 1/10</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-12%2023.52.47.png" alt="截屏2023-01-12 23.52.47" style="zoom:40%;" /></p><p>&nbsp;</p><h3 id='16-protocol-layers-service-models'><span>1.6 Protocol layers, service models</span></h3><h4 id='protocol-layers-协议层次'><span>protocol layers 协议层次</span></h4><ul><li><span>网络是一个复杂的系统! (Networks are complex, with many &quot;pieces&quot;: hosts, routers, links of various media, applications, protocols, hardware, software)</span></li><li><span>问题是：如何设计组织和实现这个复杂的计算机网络功能呢？层次化</span></li></ul><p>&nbsp;</p><p><strong><span>layering (层次化/分层)：</span></strong><span>层次化方式实现复杂网络功能，每一层实现一个服务(方法)each layer implements a service (function)</span></p><ul><li><span>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能: 服务</span></li><li><span>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务</span></li><li><span>在实现本层协议的时候，直接利用了下层所提供的服务</span></li><li><span>本层的服务: 借助下层服务实现的本层协议实体之间交互带来的新功能(上层可以利用的) + 更下层所提供的服务</span></li></ul><p><span>就像是打仗的时候，司令官(application layer)不会直接给士兵下令，而是给团长下命令一层一层传达，直到最底层士兵层(Physical layer)就不会往下传了，他只能自己指挥自己。整个下面的层次向上提供服务，团长给师长提供的服务，当然包括连长给团长提供的服务以及自己的服务，就是每一层都包括了其底下的服务 + 自己增加到新服务。通过层连接口向上提供服务。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2000.14.25.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 00.14.25"></p><p>&nbsp;</p><h4 id='service-models'><span>Service models</span></h4><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.33.27.png" alt="截屏2023-01-13 01.33.27" style="zoom:50%;" /></p><h5 id='internet-protocol-stack'><span>Internet protocol stack</span></h5><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.30.33.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 01.30.33"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2023.23.40.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 23.23.40"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.28.38.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 01.28.38"></p><p>&nbsp;</p><h5 id='isoosi-reference-model'><span>ISO/OSI reference model</span></h5><ul><li><strong><span>presentation (表示层):</span></strong><span> 允许应用 解释(interpret) 传输的数据, e.g., 加密，压缩，机器相关的表示转换</span></li><li><strong><span>session (会话层):</span></strong><span> 数据交换的同步，检查点，恢复</span></li></ul><p><strong><span>Internet protocol stack (互联网协议栈)</span></strong><span> 没有这两层! 这些服务，如果需要的话，必须被应用实现吗?</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.26.26.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 01.26.26"></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.34.49.png" alt="截屏2023-01-13 01.34.49" style="zoom:70%;" /></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.35.09.png" alt="截屏2023-01-13 01.35.09" style="zoom:70%;" /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h5 id='encapsulation-封装和解封装'><span>Encapsulation 封装和解封装</span></h5><p><strong><span>Application (应用层):</span></strong><span> 报文(message)</span></p><p><strong><span>Transport (传输层):</span></strong><span> 报文段(segment): TCP段，UDP数据报</span></p><p><strong><span>Network (网络层):</span></strong><span> 分组packet (如果无连接方式: datagram 数据报)</span></p><p><strong><span>Link (数据链路层):</span></strong><span> 帧(frame)</span></p><p><strong><span>Physical (物理层):</span></strong><span> 位(bit)</span></p><p><span>在原端做一个大的封装（从Application -&gt; Physical），在目标端做一个大的解封装（从Physical -&gt; Application）</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/%E6%88%AA%E5%B1%8F2023-01-13%2001.12.47.png" referrerpolicy="no-referrer" alt="截屏2023-01-13 01.12.47"></p><p>&nbsp;</p><h2 id='02-application-layer-交换报文实现网络应用'><u><span>02. Application layer 交换报文，实现网络应用</span></u></h2><p><span>一些网络应用的例子: E-mail, Web, 文本消息, 远程登录, P2P文件共享, 即时通信, 多用户网络游戏, 流媒体(YouTube, Hulu, Netflix), 社交网络, Internet 电话, 实时电视会议, 搜索</span></p><p><span>当我们想创造一个新的网络应用应该怎么做呢？</span></p><p><span>在端系统上编程通过网络基础设施提供的服务，应用进程彼此通信，注意：网络核心中没有应用层软件，网络核心没有应用层功能，网络应用只在端系统上存在 ，快速网络应用开发和部署。</span></p><p><img src="/Users/chenziyang/Desktop/Typora_Picture/Screenshot%202023-01-16%20at%2018.11.18.png" alt="Screenshot 2023-01-16 at 18.11.18" style="zoom:30%;" /></p><h3 id='21-principles-of-network-applications'><span>2.1 principles of network applications</span></h3><p><span>在本章中，我们学习有关 principles of network applications (应用层协议原理) 和实现方面的知识。我们从定义几个关键的应用层概念开始，其中包括应用程序所需要的网络服务、客户和服务器、进程和运输层接口。我们详细考察几种网络应用程序，包括Web、电子邮件、</span>
<span>DNS和对等文件分发。然后我们将涉及开发运行在TCP和UDP上的网络应用程序。</span></p><p><span>因此，当研发新应用程序时，你需要编写将在多台端系统上运行的软件，例如，该软件能够用C、Java或Python来编写。</span>
<span>重要的是，你不需要写在网络核心设备如路由器或链路层交换机上运行的软件. 换句话来讲，就是我们的软件是基于我们上城里有开发，你底层是怎么用什么协议去通信的我们根本不用管。如果是开发软件我们也只需要知道应用层的一些协议。</span></p><p>&nbsp;</p><p><span>应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一 (possible structure of applications):</span></p><ul><li><span>Client-server</span></li><li><span>peer-to-peer (P2P)</span></li></ul><p>&nbsp;</p><h4 id='client-server'><span>Client-server</span></h4><ul><li><u><span>在C/S体系结构中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</span></u></li><li><span>一个经典的例子是web应用程序，其中总是打开的Web服务器服务于来自浏览器(运行在客户主机上)的请求。当Web服务器按收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。(在谷歌上面输入一个URL链接，谷歌就会返回一个页面作为响应)</span></li><li><u><span>C/S体系结构的服务器具有</span><strong><span>固定的、周知的</span></strong><span>地址，该地址称为</span><strong><span>IP地址</span></strong></u><span> （我们的S端服务器的IP是固定的，谷歌的域名会被解析成一个IP）。具有C/S体系结构的应用程序包括Web、FTP、Telnet和电子邮件等.</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2021.22.55.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 21.22.55"></p><p>&nbsp;</p><h4 id='peer-to-peer-p2p'><span>peer-to-peer (P2P)</span></h4><ul><li><span>在一个P2P体系结构中，对位于数据中心的专用服务器几乎没有依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为</span><strong><span>对等方(peer-peer)</span></strong><span>。P2P体系结构的最引人入胜的特性之一是它们的</span><strong><span>自扩展性(self scalability): new peers bring new service capacity, as well as new service demands. 新的同行带来了新的业务容量，也带来了新的业务需求。</span></strong></li><li><span>P2P架构的应用也有客户端进程和服务器进程之分</span></li><li><span>但是他的数据安全性没有CS模式好。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2021.24.21.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 21.24.21"></p><h4 id='inter-process-communication-进程通信'><span>Inter-process communication 进程通信</span></h4><p><strong><span>process</span></strong><span>: a program running in a host</span></p><p><span>within same host, two processes can communicate using </span><strong><span>inter-process communication</span></strong><span> (defined by OS)</span></p><p><span>不同主机，通过交换报文(Message)来通信。对每对</span><strong><span>Inter-process communication (进程通信)</span></strong><span>，我们通常将这两个进程之一标识为客户(client)，而另一个进程标识为服务器(server)：</span></p><ul><li><strong><span>client process (客户端进程):</span></strong><span> 发起通信的进程</span></li><li><strong><span>server process (服务器进程): </span></strong><span>等待连接，然后提供服务的进程</span></li></ul><p><span>多数应用程序是由通信进程对组成，每对中的两个进程互相发送</span><strong><span>message</span></strong><span>。从一不进程向另一个进程发送的报文</span><strong><span>必须通过下层的网络</span></strong><span>。进程通过一个称为 </span><strong><span>套接字(socket)</span></strong><span> 的软件接口向网络发送报文和从网络接收报文（process sends/receives messages to/from its socket 进程向 socket 发送报文或从 socket 接收报文）</span></p><p><span>在这个图，为我们这个程序试运行在我们的应用层。应用程式由应用开发者控制。应用层之下，都是由操作系统控制。我们想要发送数据和接收数据，只能通过socket api来进行。socket 就像一个门一样，我们想要传输信息直接把数据放到这个门里面，然后对方想要接收信息就从这个门里面接收信息</span></p><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2021.43.21.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 21.43.21"></p><p>&nbsp;</p><h4 id='addressing-processes'><span>Addressing processes</span></h4><p><span>进程为了接收 massage，必须有一个 </span><strong><span>identifier(标识)</span></strong><span>。那么怎么寻址一个进程呢？</span></p><p><u><strong><span>process identifier</span></strong><span> includes both </span><strong><span>IP address</span></strong><span> and </span><strong><span>port number</span></strong><span> associated with process on host</span></u></p><ul><li><strong><span>找主机地址:</span></strong><span> 在因特网中，主机由其 </span><strong><span>32 位的 IP address</span></strong><span> 且它能够唯一地标识该主机就够了。</span></li><li><strong><span>找目的地端口号 (port number):</span></strong><span> 除了知道报文送往自的地的</span><strong><span>主机地址</span></strong><span>外，发送进程还必须指定运行在按收主机上的</span><strong><span>接收进程(接收socket)</span></strong><span>。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。</span><strong><span>目的地端口号 (port number)</span></strong><span>用于这个目的。己经给流行的应用分配了特定的端口号 (eg, HTTP server: 80, mail server: 25)</span></li></ul><p>&nbsp;</p><h4 id='what-transport-service-does-an-app-need'><span>What transport service does an app need?</span></h4><p><span>应用需要传输层提供什么样的服务? 如何描述传输层的服务? 不同的应用需要不同的传输服务</span></p><p><img src="Typora_Picture/Screenshot%202023-02-08%20at%2013.21.31.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-08 at 13.21.31"></p><ul><li><p><strong><span>data loss 数据丢失率</span></strong></p><ul><li><span>有些应用则要求100%的可靠数据传输(如文件)</span></li><li><span>有些应用(如音频)能容忍一定比例以下的数据丢失</span></li></ul></li><li><p><strong><span>delay sensitive 延迟敏感度</span></strong></p><ul><li><span>有些应用程序(如互动游戏)需要低延迟才能使用</span></li><li><span>其他一些应用程序(如电子邮件)并不关心</span></li></ul></li><li><p><strong><span>bandwidth 吞吐</span></strong></p><ul><li><span>一些应用(如多媒体)必须 需要最小限度的吞吐，从而使得应用能够有效运转</span></li><li><span>一些应用能充分利用可供使 用的吞吐(弹性应用)</span></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h4 id='internet-transport-layer-services'><span>Internet transport layer services</span></h4><p><span>Internet 传输层提供的服务</span></p><p><img src="Typora_Picture/Screenshot%202023-02-07%20at%2023.03.04.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-07 at 23.03.04"></p><p><strong><span>UDP存在的必要性</span></strong></p><ul><li><span>能够区分不同的进程，而IP服务不能，在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</span></li><li><span>无需建立连接，省去了建立连接时间，适合事务性的应用</span></li><li><span>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用。因为为了实现可靠性(准确性、保序等)，必须付出时间代价(检错重发)</span></li><li><span>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据。而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</span></li></ul><p>&nbsp;</p><h4 id='internet-apps-application--transport-layer-protocols'><span>Internet apps: application / transport layer protocols</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-08%20at%2014.52.16.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-08 at 14.52.16"></p><p>&nbsp;</p><h3 id='22-web-and-http'><span>2.2 Web and HTTP</span></h3><h4 id='web'><span>Web</span></h4><ul><li><span>Web 是一种应用，http是支持Web应用的协议</span></li><li><span>Web page consists of base HTML-file which embeds several referenced objects. object can be HTML file, JPEG image, Java applet, audio file,… Web 页面 (Web page) (也叫文档)是由对象组成的。 一个对象 (object) 只是一个文件，诸如一个HTML文件、一个JPEG图形、 一个Java小程序或一个视频片段这样的文件， 且它们可通过一个URL地址寻址。 多数Web页面含有一个HTML基本文件 (baseHTML file) 以及几个引用对象。 例如，如果一个Web页面包含HTML文本和5个JPEG图形，那么这个 Web 页面有 6 个对象: 一个 HTML 基本文件加 5 个图形 。</span></li><li><strong><span>URL: Uniform Resource Locator 通用资源定位</span></strong></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-08%20at%2015.48.21.png" alt="Screenshot 2023-02-08 at 15.48.21" style="zoom:43%;" /></p><p>&nbsp;</p><h4 id='http'><span>HTTP</span></h4><p><span>HTTP: hypertext transfer protocol (超文本传输协议) 文本与文本之间任意指向的关系</span></p><p><span>Web的应用层协议</span></p><p><strong><span>client/server model (客户/服务器模式):</span></strong></p><ul><li><strong><span>client:</span></strong><span> 请求、接收和显示 Web对象的浏览器 </span><strong><span>(request)</span></strong></li><li><strong><span>server:</span></strong><span> 对请求进行响应， 发送对象的Web服务器 </span><strong><span>(response)</span></strong></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2001.11.33.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 01.11.33"></p><p>&nbsp;</p><p>&nbsp;</p><h4 id='non-persistent-http--persistent-http'><span>Non-persistent HTTP &amp; Persistent HTTP</span></h4><p><span>在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。</span></p><p><span>依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的 </span><u><strong><span>间隔周期性</span></strong><span> 地或者 </span><strong><span>问断性地一个按一个发出</span></strong></u><span>。当这种客户-服务器的交互是经TCP进行的，应用程序的研制者就需要做一个重要决定，即每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发送呢？</span></p><p><span>即每个请求/响应对是经一个单独的 TCP 连接发送，还是所有的请求及其响应经相同的 TCP 连接发送?</span></p><ul><li><span>每个请求/响应对是经一个单独的 TCP 连接发送 就是 Non-persistent HTTP</span></li><li><span>所有的请求及其响应经相同的 TCP 连接发送 就是 Persistent HTTP</span></li></ul><p><span>HTTP既能够使用非持续连接，也能够使用持续连接:</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2014.41.11.png" alt="Screenshot 2023-02-09 at 14.41.11" style="zoom:50%;" /></p><p>&nbsp;</p><h5 id='non-persistent-http'><span>Non-persistent HTTP</span></h5><p><strong><span>往返时间RTT(round-trip time)</span></strong><span>: 一个小的分组从客户端到服务器，在回到客户端的时间(传输时间忽略)</span></p><p><span>这引起浏览器在它和 Web 服务器之间发起一个 TCP 连接;这涉及一次“三次握手”过程，</span></p><p><span>即客户向服务器发送一个小 TCP 报文段，服务器用一个小 TCP 报文段做出确认和响应， 最后，客户向服务器返回确认 。 三次握手中前两个部分所耗费的时间占用了一个 RTT。 完 成了三次握手的前两个部分后，客户结合 三次握手的第三部分(确认)向该 TCP 连接发 送一个 HTTP 请求报文 。 一 旦该请求报文到达服务器，服务器就在该 TCP 连接上发送 HTML文件 。 该 HTTP 请求/响应用去了另 一个 RTT。 因此，粗略地讲，总的响应时间就是两个 RTT 加上服务器传输 HTML 文件的时间 。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2015.09.33.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 15.09.33"></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2015.10.14.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 15.10.14"></p><p><span>缺点：</span></p><ul><li><span>每个对象要2个 RTT</span></li><li><span>操作系统必须为每个TCP连接分配资源。（必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，因为一台Web服务器可能同时服务于数以百计不同的客户的请求。）</span></li></ul><p>&nbsp;</p><h5 id='persistent-http'><span>Persistent HTTP</span></h5><ul><li><span>服务器在发送响应后保持连接打开。</span></li><li><span>同一客户端/服务器之间的后续HTTP消息通过开放连接发送。</span></li><li><span>客户端在遇到引用对象时立即发送请求。</span></li><li><span>对于所有引用的对象，只需一个RTT。</span></li></ul><p>&nbsp;</p><p>&nbsp;</p><h4 id='http-message-format'><span>HTTP message format</span></h4><p><span>HTTP 规范 [RFC 1945; RFC 2616; RFC 7540] 包含了对 HTTP 报文格式的定义。</span></p><p><span>HTTP 报文有两种:请求报文和响应报文。</span></p><p><strong><span>Method type</span></strong></p><p><span>put一般是修改，get查询，post增加/提交，delete删除</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2016.55.56.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 16.55.56"></p><h5 id='http-request-message-format'><span>HTTP request message format</span></h5><p><span>Get 请求报文一般没有实体行</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2016.58.58.png" alt="Screenshot 2023-02-09 at 16.58.58" style="zoom:50%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2016.52.12.png" alt="Screenshot 2023-02-09 at 16.52.12" style="zoom:50%;" /></p><p><strong><span>Uploading form input:</span></strong></p><ul><li><strong><span>Post：</span></strong><span>使用 POST 方法时使用该实体体。当用户提交表单时，HTTP客户常常使用 POST 方法，例如当用户向搜素引擎提供搜索关键词时。使用 POST 报文时，用户仍可以向服务器请求一个web 页面，但web页面的特定内容依赖于用户在表单字段中输入的内容。如果方法字段的值为 POST 时，则实体体中包含的就是用 户在表单字段中的输人值。</span></li><li><strong><span>Get：</span></strong><span>使用 GET 方法时实体体（entily body）为空</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2017.15.15.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 17.15.15"></p><p>&nbsp;</p><h5 id='http-response-message-format'><span>HTTP response message format</span></h5><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2018.00.36.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 18.00.36"></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2019.46.57.png" alt="Screenshot 2023-02-09 at 19.46.57" style="zoom:50%;" /></p><h5 id='http-response-status-codes'><span>HTTP response status codes</span></h5><p><span>位于服务器 -&gt; 客户端的响应报文中的首行</span></p><p><span>一些状态码的例子:</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2020.35.35.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 20.35.35"></p><p>&nbsp;</p><h4 id='user-server-state-cookies'><span>User-server state: cookies</span></h4><p><span>header line 首部行</span></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2021.06.33.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 21.06.33"></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2021.28.20.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 21.28.20"></p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2021.28.46.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 21.28.46"></p><h4 id='web-caching-proxy-server'><span>Web caching (proxy server)</span></h4><ul><li><strong><span>Web 缓存器 (Web cache)</span></strong><span> 也叫代理服务器 (proxy server) , 它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。</span></li><li><span>Web 缓存器有自己的磁盘存储空间， 并在存储空间中保存最近请求过的对象的副本。</span></li><li><span>可以配置用户的浏览器，使得用户的所有 HTTP 请求首先指向 Web 缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web 缓存器 。</span></li><li><span>缓存既是客户端又是服务器，通常缓存是由ISP安装 (大学、公司、居民区ISP)</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2021.33.08.png" alt="Screenshot 2023-02-09 at 21.33.08" style="zoom:50%;" /></p><p><span>为什么要使用Web缓存 ?</span></p><ul><li><span>降低客户端的请求响应时 间</span></li><li><span>可以大大减少一个机构内 部网络与Internent接入 链路上的流量</span></li><li><span>互联网大量采用了缓存: 可以使较弱的ICP也能够 有效提供内容</span></li></ul><p>&nbsp;</p><p><img src="Typora_Picture/Screenshot%202023-02-09%20at%2022.54.23.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-09 at 22.54.23"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='23-email'><span>2.3 Email</span></h3><p><span>因特网电子邮件系统的总体情况，有3个主要组成部分：</span></p><ul><li><p><strong><span>user agents (用户代理):</span></strong><span> 又名 “邮件阅读器”, 撰写、编辑和阅读邮件。如Outlook、Foxmail，输出和输入邮件保存在服务器上</span></p></li><li><p><strong><span>mail servers (邮件服务器):</span></strong><span> 邮箱中管理和维护发送给用户的邮件，输出报文队列保持待发送邮件报文</span></p></li><li><p><strong><span>Simple Mail Transfer Protocol (简单邮件传输协议):</span></strong><span> SMTR是因特网电子邮件中主要的应用层协议。</span></p><p><span>client: sending mail server</span></p><p><span>server: receiving mail server</span></p></li></ul><p><span>agents = 通过用户代理软件来访问电子邮件这个应用，因此这个软件就是我们这个应用的代理。浏览器是Web应用的应用代理</span></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2014.06.39.png" alt="Screenshot 2023-02-13 at 14.06.39" style="zoom:50%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2015.05.41.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-13 at 15.05.41"></p><p>&nbsp;</p><h4 id='smtp-rfc-2821'><span>SMTP [RFC 2821]</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2015.03.59.png" alt="Screenshot 2023-02-13 at 15.03.59" style="zoom:60%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2015.20.48.png" alt="Screenshot 2023-02-13 at 15.20.48" style="zoom:60%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2015.44.43.png" alt="Screenshot 2023-02-13 at 15.44.43" style="zoom:67%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2016.59.45.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-13 at 16.59.45"></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2017.00.01.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-13 at 17.00.01"></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2017.00.14.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-13 at 17.00.14"></p><p><img src="Typora_Picture/Screenshot%202023-02-13%20at%2017.00.51.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-13 at 17.00.51"></p><p>&nbsp;</p><h3 id='24-dns'><span>2.4 DNS</span></h3><p><span>Domain Name System 运行在UDP上</span></p><p><span>域名/主机名 =&gt; IP地址</span></p><p><span>在IP协议中，我们与目标主机交互，需要记住对方的IP192.168.0.1，这就像我们要记住好多朋友的电话一样。电话也太难记了，所以我们需要有个电话本，记录小明 =&gt; 18316160606的对应关系。好比</span><a href='http://www.baidu.com' target='_blank' class='url'>www.baidu.com</a><span>对应10.0.21.4。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-14%20at%2020.18.49.png" alt="Screenshot 2023-02-14 at 20.18.49" style="zoom:40%;" /></p><ul><li><p><strong><span>主机别名 (host aliasing): </span></strong><span>有着复杂主机名的主机能拥有一个或者多个别名</span></p><p><span>例如，一台名为 relayl. west- coast. enterprise. com 的主机，可能还有两个别名为 enter­ prise. com 和 www. enterprise.com</span></p><p><span>在这种情况下， relay1. west- coast enterprise. com 也称为 </span><strong><span>规范主机名 (canonical hoslname)</span></strong><span> 。 主机别名(当存在时)比主机规范名更 加容易记忆 。 应用程序可以调用 DNS 来获得主机别名对应的规范主机名以及主机的 IP地址。</span></p></li><li><p><strong><span>邮件服务器别名 (mail server aliasing): </span></strong><span>显而易见，人们也非常希望电子邮件地址好记忆。</span></p><p><span>例如，如果 Bob在雅虎邮件上有一个账户， Bob 的邮件地址就像 hob@ya­hoo. com这样简单。 然而，雅虎邮件服务器的主机名可能更为复杂，不像 ya­hoo. com 那样简单好记(例如，规范主机名可能像 relay1. west- coasL hotmail com 那样)。</span></p><p><span>电子邮件应用程序可以调用 DNS，对提供的主机名别名进行解析，以获得该主机的规范主机名及其 IP 地址。</span></p><p><span>事实上，MX 记录(参见后面)允许一个公司的邮件服务器和 Web 服务器使用相同(别名化的)的主机名，例如，一个公司的 Web 服务器和邮件服务器都能叫作 enterprise. com。</span></p></li><li><p><strong><span>负载分配 (load distribution)</span></strong><span> 。 DNS 也用千在冗余的服务器(如冗余的 Web 服务器 等)之间进行负载分配 。 繁忙的站点(如 cnn. com) 被冗余分布在多台服务器上 ， 每台服务器均运行在不同的端系统上，每个都有着不同的 IP 地址 。 由千这些冗余 的 Web 服务器， 一个 IP 地址集合因此与同一个规范主机名相联系 。 DNS 数据库中 存储着这些 IP 地址集合 。 当客户对映射到某地址集合的名字发出一个 DNS 请求 时，该服务器用 IP 地址的整个集合进行响应，但在每个回答中循环这些地址次 序 。 因为客户通常总是向 IP 地址排在最前面的服务器发送 HTTP 请求报文，所以 DNS 就在所有这些冗余的 Web 服务器之间循环分配了负载 。 DNS 的循环同样可以 用千邮件服务器，因此，多个邮件服务器可以具有相同的别名。一些内容分发公 司如 Akamai 也以更加复杂的方式使用 DNS [ Dilley 2002] , 以提供 Web 内容分发</span></p></li></ul><p>&nbsp;</p><p><img src="Typora_Picture/Screenshot%202023-02-14%20at%2020.28.43.png" alt="Screenshot 2023-02-14 at 20.28.43" style="zoom:40%;" /></p><p>&nbsp;</p><h4 id='dns-name-space'><span>DNS Name Space</span></h4><p><img src="Typora_Picture/1653728249232-a57e0bde-fd8e-4a93-aba5-ee6667ccf476.jpeg" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。</span></p><p>&nbsp;</p><h4 id='dns-hierarchy'><span>DNS hierarchy</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-14%20at%2021.13.44.png" alt="Screenshot 2023-02-14 at 21.13.44" style="zoom:33%;" /></p><ul><li><strong><span>根域名服务器 (root name servers):</span></strong><span> 根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-14%20at%2020.53.30.png" alt="Screenshot 2023-02-14 at 20.53.30" style="zoom:30%;" /></p><p>&nbsp;</p><ul><li><p><strong><span>顶级域名服务器 (top-level domain (TLD) servers)</span></strong><span> 这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</span></p><ul><li><span>负责com, org, net, edu, aero，博物馆和所有顶级国家域名，例如:uk, fr, ca, jp</span></li><li><u><span>Network Solutions</span></u><span> maintains servers for </span><u><span>com</span></u><span> TLD</span></li><li><u><span>Educause</span></u><span> for </span><u><span>edu</span></u><span> TLD</span></li></ul><p>&nbsp;</p></li><li><p><strong><span>权威域名服务器 (authoritative DNS servers):</span></strong><span> 这些域名服务器负责</span><u><span>管理某个区的域名</span></u><span>。每一个主机的域名都必须在某个权限域名服务器处注册登记。</span><u><span>因此权限域名服务器知道其管辖的域名与IP地址的映射关系</span></u><span>。另外，权限域名服务器还知道其下级域名服务器的地址。</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-14%20at%2021.03.59.png" alt="Screenshot 2023-02-14 at 21.03.59" style="zoom:30%;" /></p><p>&nbsp;</p><p>&nbsp;</p><h4 id='local-dns-server'><span>Local DNS server</span></h4><p><span>本地域名服务器</span><strong><span>不属于</span></strong><span>上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。</span><strong><span>本地域名服务器起着代理的作用</span></strong><span>，会将该报文转发到上述的域名服务器的等级结构中。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</span></p><ul><li><span>并不严格属于层次结构</span></li><li><span>每个ISP (居民区的ISP、公司、大学)都有一个本地DNS服务器，也称为“默认名字服务器”</span></li><li><span>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器。起着代理的作用，将查询转发到层次结构中</span></li></ul><center>
  <img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.30.05.png" alt="Screenshot 2023-02-15 at 12.30.05" style="zoom:43%;">
  <br>
  如果目标名字在Local Name Server中</center><p>&nbsp;</p><p>&nbsp;</p><h4 id='domain-name-resolution'><span>Domain name resolution</span></h4><p><span>域名解析分为两种，递归和迭代。</span></p><h5 id='recursive-query'><span>recursive query</span></h5><ul><li><span>名字解析负担都放在当前联络的名字服务器上</span></li><li><span>问题：root DNS server 的负担太重，所以我们要学习/使用 iterated queries</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.33.51.png" alt="Screenshot 2023-02-15 at 12.33.51" style="zoom:40%;" /></p><h5 id='iterated-query'><span>iterated query</span></h5><ul><li><span>迭代的方式，大大节省了根域名服务器的压力。</span></li><li><span>由于域名解析的报文并不长，DNS域名解析的过程采用的UDP的传输协议，大大的增加了传输间的效率。</span></li><li><span>DNS解析服务器是分布式的，在主域名解析服务器向其他域名解析服务器直接同步数据时，采用的是TCP的传输协议。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2000.19.24.png" alt="Screenshot 2023-02-15 at 00.19.24" style="zoom:40%;" /></p><p><span>当你输入一个网址的时候：</span></p><ol start='' ><li><span>请求本地缓存，查询host域名配置</span></li><li><span>本地缓存没有，查询本地DNS服务器。什么是本地DNS服务器呢？其实并不是配置在你家里的，而是你的宽带属于哪个服务商，就会使用哪个服务商的DNS。</span></li><li><span>本地DNS服务器没有缓存，查询根域名服务器。</span></li><li><span>根域名服务器会指向顶级域名服务器</span></li><li><span>顶级域名服务器会指向权威域名服务器</span></li><li><span>最终拿到权威域名服务器结果，并缓存在本地DNS服务器</span></li></ol><p>&nbsp;</p><h4 id='dns-caching-updating-records'><span>DNS: caching, updating records</span></h4><ul><li><span>一旦(任何)名称服务器学会了映射，它就 </span><strong><span>caches mapping (缓存映射)</span></strong><span>，由于 主机和主机名 与 IP 地址间的映射并不是永久的，local DNS 服务器在 </span><u><strong><span>一段时间后 (TTL, 通常设置为两天)</span></strong></u><span>将丢弃缓存的信息。</span></li><li><span>TLD服务器通常缓存在本地名称服务器中，因此根名称服务器不常被访问</span></li><li><strong><span>cached entries(缓存的条目)</span></strong><span> 可能会 </span><strong><span>out-of-date 过期</span></strong><span> (尽最大努力将名称转换为地址!)，如果name host更改了IP地址，可能直到缓存条目的所有TTLs过期才会被全网所知</span></li><li><span>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了 资源记录 (Resource Record , RR), RR 提供了主机名到 IP 地址的映射，每个 DNS 回答报文包含了一条或多条资源记录</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.59.54.png" alt="Screenshot 2023-02-15 at 12.59.54" style="zoom:40%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.51.26.png" alt="Screenshot 2023-02-15 at 12.51.26" style="zoom:40%;" /></p><p>&nbsp;</p><p>&nbsp;</p><h4 id='dns-protocol-messages'><span>DNS protocol, messages</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.41.32.png" alt="Screenshot 2023-02-15 at 12.41.32" style="zoom:40%;" /></p><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2012.42.01.png" alt="Screenshot 2023-02-15 at 12.42.01" style="zoom:45%;" /></p><p>&nbsp;</p><h4 id='inserting-records-into-dnse'><span>Inserting records into DNSe</span></h4><p><span>上面的讨论只是关注如何从 DNS 数据库中取数据。你可能想知道这些数据最初是怎 么进入数据库中的</span></p><p><img src="Typora_Picture/Screenshot%202023-02-15%20at%2014.42.54.png" alt="Screenshot 2023-02-15 at 14.42.54" style="zoom:50%;" /></p><p>&nbsp;</p><h3 id='27-socket-programming-with-udp-and-tcp'><span>2.7 socket programming with UDP and TCP</span></h3><p><span>典型的网络应用是由一对程序(即客户程序和服务器程序)组成的，它们位于两个不同的端系统中。当运行这两个程序时，创建了一个客户进程和一个服务器进程，同时它们通过从套接字读出和写入数据在彼此之间进行通信。 开发者创建一个网络应用时，其主要任务就是编写 client 程序和 server 程序的代码。</span></p><p><span>目标: 学习如何构建能借助sockets进行通信的C/S应用程序（eg. 服务器与客户端的交互：服务器接收数据并将字符转换为大写，服务器将修改后的数据发送到客户端，客户端接收修改后的数据并在其屏幕上显示行）</span></p><ul><li><span>socket 其实就是操作系统提供给程序员操作「网络协议栈」的接口，是一套用于不同 host 间通信的API，你能通过socket 的接口，来控制协议栈工作，从而用它来实现网络通信，达到跨主机通信。</span></li><li><span>他工作在我们的TCP IP协议栈之上</span></li><li><span>要通过 socket 与不同的组织建立联系，我们只需要指定主机的IP号和端口号，IP地址用于唯一标识你的网络设备。那为什么还要额外指定一个端口好呢？如果没有端口，操作系统就没有办法区分数据到底应该发到哪一个应用之上。因此，端口主要用于区分主机上的不同应用。</span></li><li><span>通过 socket 我们可以建立一条用于不同组织不同应用之间的虚拟数据通道，并且他是应用对应用的，就像是一条数据线，连接在不同应用的插槽上。</span></li></ul><p><span>socket建立之后，我们的消息收发都通过socket，变得非常方便。Socket是双方会话关系的本地标识。在研发阶段，开发者必须最先做的一个决定是: 应用程序是运行在 TCP上还是运行在 UDP上。</span></p><p><strong><span>socket 一般分为 TCP 网络编程和 UDP 网络编程。</span></strong></p><ul><li><p><span>针对</span><strong><span>TCP协议 (reliable, Data Stream, byte streamoriented)</span></strong><span>，Socket是一个</span><strong><u><span>四元组 (本地ip，本地port，对方ip，对方port).</span></u></strong><span> </span></p><ul><li><span>TCP是 面向连接的，并且为两个端系统之间的数据流动提供 </span><strong><span>可靠的字节流通道 (TCP provides reliable, in-order byte-stream transfer (“pipe”) between client and server)</span></strong></li><li><span>TCP 要求收发数据的双方扮演不同的角色：Server/Client</span></li></ul></li><li><p><span>针对</span><strong><span>UDP协议 (unreliable datagram)</span></strong><span>，Socket是一个</span><strong><u><span>二元组 (本地ip，本地port).</span></u></strong><span> </span></p><ul><li><span>UDP 是无连接的，且发送数据前不握手，从一个端系统向另一个端系统发送独立的数据分组，不对交付提供任何保证。</span></li><li><span>sender 将目标的 IP 地址和端口# 显式附加到 each packet</span></li><li><span>receiver 从收到的数据包中提取发送方的IP地址和端口。传输的数据可能会丢失或无序接收</span></li></ul></li></ul><p><span>我们通过一个简单的 UDP 应用程序和一个简单的 TCP应用程序来介绍 UDP 和 TCP套接字编程。</span></p><p>&nbsp;</p><h4 id='tcp-socket-programming'><span>TCP socket programming</span></h4><h5 id='tcp-server'><span>TCP Server</span></h5><p><span>服务器首先运行，等待连接建立：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">socket</span> <span class="cm-keyword">import</span><span class="cm-operator">*</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><ol start='' ><li><strong><span>ServerSocket:</span></strong><span> </span><strong><span>创建 </span></strong><span>服务器套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverSocket</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_STREAM</span>) <span class="cm-comment">## 创建 TCP 服务器 welcoming socket</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 第一个参数指示底层网络使用的是 IPv4。第二个参数指示该 socket 是 SOCK_STREAM 类型，这表明它是一个 TCP socket</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 44px;"></div><div class="CodeMirror-gutters" style="display: none; height: 44px;"></div></div></div></pre><ol start='2' ><li><strong><span>bind:</span></strong><span> 将套接字 </span><strong><span>绑定 </span></strong><span>到一个本地地址和端口上</span></li><li><strong><span>listen:</span></strong><span> 将套接字设定为监听模式，准备接受客户端请求</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverSocket</span>.<span class="cm-property">bind</span>((<span class="cm-string">'0.0.0.0'</span>, <span class="cm-number">12000</span>)) <span class="cm-comment">## 将我们创建的 socket 关联到我们主机的某一个 network interface(IP) 和 port 上</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverSocket</span>.<span class="cm-property">listen</span>(<span class="cm-number">1</span>) <span class="cm-comment">## 将socket设定为监听模式, 准备接受客户端请求/聆听某个客户敲门, 其中参数定义了请求连接的最大数(至少为1)</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span> (<span class="cm-string">'The server is ready to receive'</span>)</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 66px;"></div><div class="CodeMirror-gutters" style="display: none; height: 66px;"></div></div></div></pre><ol start='4' ><li><strong><span>accept: 阻塞</span></strong><span> 等待客户端请求到来。当请求到来后，接受连接请求，返回一个新的对应于此客户端连接的套接字socketClient</span></li><li><strong><span>IO流操作:</span></strong><span> 用返回的套接字socketClient和客户端进行通信</span></li><li><strong><span>accept:</span></strong><span> 返回，等待另一个客户端请求</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>: <span class="cm-comment">## loop forever</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-variable">connectionSocket</span>, <span class="cm-variable">addr</span> <span class="cm-operator">=</span> <span class="cm-variable">serverSocket</span>.<span class="cm-property">accept</span>() </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">## 当客户敲该门时，程序为 serverSocket 调用 accept()方法</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">## 这在服务器中创建了一个称为 connectionSocket 的新socket，由这个特定的客户专用。</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">## 客户和服务器则完成了握手，在 客户的 clientSocket 和服务器的 serverSocket 之间创建了 一个 TCP 连接。</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-variable">sentence</span> <span class="cm-operator">=</span> <span class="cm-variable">connectionSocket</span>.<span class="cm-property">recv</span>(<span class="cm-number">1024</span>).<span class="cm-property">decode</span>() <span class="cm-comment">## read bytes from socket (but not address as in UDP)</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-variable cm-error">capitalizedSentence</span> <span class="cm-operator">=</span> <span class="cm-variable">sentence</span>.<span class="cm-property">upper</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-variable">connectionSocket</span>.<span class="cm-property">send</span>(<span class="cm-variable">capitalizedSentence</span>.<span class="cm-property">encode</span>()) </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-comment">## 借助于创建的 TCP 连接，客户与服务器现在能够通过该连接相互发送字节。</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-comment">## 使用 TCP, 从一侧发送的所有字节不仅确保到达另一侧，而且确保按序到达。</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 242px;"></div><div class="CodeMirror-gutters" style="display: none; height: 242px;"></div></div></div></pre><ol start='7' ><li><strong><span>close:</span></strong><span> 关闭套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-variable">connectionSocket</span>.<span class="cm-property">close</span>() <span class="cm-comment">## close connection to this client (but not welcoming socket)</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><p>&nbsp;</p><h5 id='tcp-client'><span>TCP Client</span></h5><p><span>客户端主动和服务器建立连接：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">socket</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><ol start='' ><li><strong><span>Socket:</span></strong><span> 创建客户端套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_STREAM</span>) </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 该行创建了client socket，称为 clientSocket</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 第一个参数仍指示底层网络使用的是 IPv4. 第二个参数指示该套接字是 SOCK_STREAM 类型. 这表明它是一个 TCP 套接字</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 66px;"></div><div class="CodeMirror-gutters" style="display: none; height: 66px;"></div></div></div></pre><p><span>值得注意的是当我们创建该客户套接字时仍未指定其端口号; 相反，我们让操作系统为我们做此事（没有bind）</span></p><ol start='2' ><li><strong><span>connect:</span></strong><span> 向服务器发出连接请求</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span>.<span class="cm-property">connect</span>((<span class="cm-string">"127.0.0.1"</span>, <span class="cm-number">12000</span>)) </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## create TCP socket for server, remote port 12000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 这行代码执行完后, 执行三次握手, 并在客户和服务器之间创建起一条 TCP 连接</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 66px;"></div><div class="CodeMirror-gutters" style="display: none; height: 66px;"></div></div></div></pre><ol start='3' ><li><strong><span>IO流操作:</span></strong><span> 和服务器进行通信</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">sentence</span> <span class="cm-operator">=</span> <span class="cm-builtin">input</span>(<span class="cm-string">'Input lowercase sentence:'</span>) <span class="cm-comment">## 从用户获得了一个句子, 字符串 sentence 连续收集字符 直到用户键入回车以终止</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span>.<span class="cm-property">send</span>(<span class="cm-variable">sentence</span>.<span class="cm-property">encode</span>()) <span class="cm-comment">## 发送 sentence 到 TCP, 无需附加 server name, port </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">modifiedSentence</span> <span class="cm-operator">=</span> <span class="cm-variable">clientSocket</span>.<span class="cm-property">recv</span>(<span class="cm-number">1024</span>) <span class="cm-comment">## 当字符到达服务器时，它们被放置在字符串 modifiedSentence 中</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span> (<span class="cm-variable">‘From</span> <span class="cm-variable">Server</span>:<span class="cm-variable">’</span>, <span class="cm-variable">modifiedSentence</span>.<span class="cm-property">decode</span>())</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 88px;"></div><div class="CodeMirror-gutters" style="display: none; height: 88px;"></div></div></div></pre><ol start='4' ><li><strong><span>close:</span></strong><span> 关闭套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span>.<span class="cm-property">close</span>() <span class="cm-comment">## 关闭套接字，因此关闭了客户和服务器之间的 TCP 连接. 它引起客户中的TCP向服务器中的TCP发送一条TCP报文</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><p>&nbsp;</p><h4 id='cs-socket-interaction-tcp'><span>C/S socket interaction: TCP</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-16%20at%2019.35.10.png" alt="Screenshot 2023-02-16 at 19.35.10" style="zoom:53%;" /></p><p>&nbsp;</p><h4 id='udp-socket-programming'><span>UDP socket programming</span></h4><ul><li><span>在客户端和服务器之间没有连接，没有握手</span></li><li><span>发送端在每一个报文中明确地指定目标的IP地址和端口 号</span></li><li><span>服务器必须从收到的分组中提取出发送端的IP地址和端 口号</span></li><li><span>传送的数据可能乱序， 也可能丢失（不可靠的字节组的传送服务）</span></li></ul><p>&nbsp;</p><h5 id='udp-server'><span>UDP Server</span></h5><p><span>只有一个socket：</span></p><figure><table><thead><tr><th><span>Socket</span></th><th><span>IP</span></th><th><span>Port</span></th></tr></thead><tbody><tr><td><span>8888</span></td><td><span>1.1.1.1</span></td><td><span>80</span></td></tr></tbody></table></figure><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">socket</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><ol start='' ><li><strong><span>serverSocket:</span></strong><span> 创建套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">socket</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverPort</span> <span class="cm-operator">=</span> <span class="cm-number">12000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverSocket</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_DGRAM</span>) <span class="cm-comment">## create UDP socket, SOCK_DGRAM = UDP</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 66px;"></div><div class="CodeMirror-gutters" style="display: none; height: 66px;"></div></div></div></pre><ol start='2' ><li><strong><span>bind:</span></strong><span> 将套接字绑定到一个本地地址和端口上</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverSocket</span>.<span class="cm-property">bind</span>((<span class="cm-string">''</span>, <span class="cm-variable">serverPort</span>))</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span> (<span class="cm-string">'The server is ready to receive'</span>)</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 44px;"></div><div class="CodeMirror-gutters" style="display: none; height: 44px;"></div></div></div></pre><ol start='3' ><li><strong><span>recvfrom:</span></strong><span> 阻塞等待接收消息</span></li><li><span>收到的消息被封装在 modifiedMessage 里，里面有对方的ip和端口</span></li><li><strong><span>sendto:</span></strong><span> 可以根据对方的DatagramPacket再像对方发送消息</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span> <span class="cm-keyword">True</span>:</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">message</span>, <span class="cm-variable">clientAddress</span> <span class="cm-operator">=</span> <span class="cm-variable">serverSocket</span>.<span class="cm-property">recvfrom</span>(<span class="cm-number">2048</span>) <span class="cm-comment">## 从 UDP socket 读取消息，获取 client IP 和 port</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">modifiedMessage</span> <span class="cm-operator">=</span> <span class="cm-variable">message</span>.<span class="cm-property">decode</span>().<span class="cm-property">upper</span>() <span class="cm-comment">## send upper case string back to this client</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">serverSocket</span>.<span class="cm-property">sendto</span>(<span class="cm-variable">modifiedMessage</span>.<span class="cm-property">encode</span>(), <span class="cm-variable">clientAddress</span>)</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 88px;"></div><div class="CodeMirror-gutters" style="display: none; height: 88px;"></div></div></div></pre><p>&nbsp;</p><h5 id='udp-client'><span>UDP Client</span></h5><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">from</span> <span class="cm-variable">socket</span> <span class="cm-keyword">import</span> <span class="cm-operator">*</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><ol start='' ><li><strong><span>clientSocket:</span></strong><span> 创建客户端套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverName</span> <span class="cm-operator">=</span> <span class="cm-variable">‘hostname’</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">serverPort</span> <span class="cm-operator">=</span> <span class="cm-number">12000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_DGRAM</span>) <span class="cm-comment">## 创建了客户的套接字，称为 clienLSocket</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 第一个参数指示了地址簇, AF_INET 指示了底层网络使用了 IPv4</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">## 第二个参数指示了该套接字是 SOCK_DGRAM 类型的，这意味着它是一个 UDP 套接字</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 110px;"></div><div class="CodeMirror-gutters" style="display: none; height: 110px;"></div></div></div></pre><ol start='2' ><li><strong><span>message:</span></strong><span> 创建小写用户输入字符串。</span></li><li><strong><span>sendto(): </span></strong><span>为报文附上目的地址 (serverName , serverPort) 并且向进程的套接字 </span><strong><span>clientSocket</span></strong><span> 发送结果分组</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">message</span> <span class="cm-operator">=</span> <span class="cm-builtin">input</span>(<span class="cm-string">'Input lowercase sentence:'</span>) <span class="cm-comment">## get user keyboard input </span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span>.<span class="cm-property">sendto</span>(<span class="cm-variable">message</span>.<span class="cm-property">encode</span>(),(<span class="cm-variable">serverName</span>, <span class="cm-variable">serverPort</span>)) <span class="cm-comment">## Attach server name, port to message; send into socket</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 66px;"></div><div class="CodeMirror-gutters" style="display: none; height: 66px;"></div></div></div></pre><ol start='4' ><li><strong><span>modifiedMessage:</span></strong><span> 将server修改完的字符串从 socket 放入 modifiedMessage</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">modifiedMessage</span>, <span class="cm-variable">serverAddress</span> <span class="cm-operator">=</span> <span class="cm-variable">clientSocket</span>.<span class="cm-property">recvfrom</span>(<span class="cm-number">2048</span>) <span class="cm-comment">## read reply characters from socket into string</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span> (<span class="cm-variable">modifiedMessage</span>.<span class="cm-property">decode</span>()) <span class="cm-comment">## 打印出 modifiedMessage 大写字符串</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 44px;"></div><div class="CodeMirror-gutters" style="display: none; height: 44px;"></div></div></div></pre><ol start='5' ><li><strong><span>close:</span></strong><span> 关闭套接字</span></li></ol><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="py"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="py"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: currentcolor;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: currentcolor;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">clientSocket</span>.<span class="cm-property">close</span>()</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><p><span>我们可以发现，tcp和udp各自用一套端口，哪怕都是8000，但是互不冲突。</span></p><p>&nbsp;</p><h4 id='cs-socket-interaction-udp'><span>C/S socket interaction: UDP</span></h4><p><img src="Typora_Picture/Screenshot%202023-02-16%20at%2019.34.36.png" alt="Screenshot 2023-02-16 at 19.34.36" style="zoom:43%;" /></p><p>&nbsp;</p><h2 id='03-transport-layer-进程间的逻辑通信'><u><span>03. Transport Layer 进程间的逻辑通信</span></u></h2><p><span>运输层协议为运行在不同 主机上的</span><strong><span>应用进程之间</span></strong><span>提供了 </span><strong><span>逻辑通信 (logic communicalion) 功能</span></strong></p><p><span>从应用程序的角度看，通过逻辑通信，运行不同进程的主机好像使用socket直接相连一样;</span></p><p><span>实际上，这些主机也许位于地球的两侧，通过很多路由器及多种不同类型的链路相连。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些 message 的物理基础设施的细节</span></p><p><img src="Typora_Picture/Screenshot%202023-02-16%20at%2022.14.32.png" alt="Screenshot 2023-02-16 at 22.14.32" style="zoom:50%;" /></p><p>&nbsp;</p><h3 id='31-transport-layer-services-and-protocols'><span>3.1 transport-layer services and protocols</span></h3><ul><li><p><span>为运行在不同主机上的应用进程提供 </span><strong><span>logical end-to-end connection (逻辑通信)</span></strong><span>，逻辑通信的意思是“好像是这样通信，但事实上并非真的这样通信”。</span></p></li><li><p><span>Transport layer protocols run in </span><strong><span>end systems</span></strong><span> (传输协议运行在端系统)</span></p><ul><li><span>发送方: </span><u><span>breaks application </span><strong><span>messages</span></strong><span> into </span><strong><span>segments</span></strong><span>, passes to network layer</span></u><span> (将应用层的报文分成报文段，传递给网络层)</span></li><li><span>接收方: </span><u><strong><span>reassembles segments</span></strong><span> into </span><strong><span>messages</span></strong><span>, passes to application layer</span></u><span> (将报文段重组成报文，然后传递给应用层)</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-16%20at%2023.07.56.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-16 at 23.07.56"></p><ul><li><p><span>网络应用程序可以使用多种的运输层协议 (Internet传输层协议有两种，即 TCP 和 UDP). 每种协议都能为调用的应用程序提供一组不同的运输层服务。</span></p></li><li><p><strong><span>TCP: reliable, data stream, in-order delivery</span></strong></p><ul><li><span>多路复用、解复用</span></li><li><span>congestion control (拥塞控制)</span></li><li><span>flow control (流量控制)</span></li><li><span>connection setup (建立连接)</span></li></ul></li><li><p><strong><span>UDP: unreliable, datagram, unordered delivery</span></strong></p><ul><li><span>多路复用、解复用</span></li><li><span>extension of “best-effort” IP (从network layer的主机到主机变成了进程到进程，除此之外，就没有添加更多的其它额外服务了)</span></li></ul></li></ul><p><span>都不提供的服务: delay guarantees(延时保证), bandwidth guarantees(带宽保证)</span></p><p>&nbsp;</p><h3 id='32-multiplexing-and-demultiplexing'><span>3.2 multiplexing and demultiplexing</span></h3><p><span>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信，一个进程(作为网络应用的一部分)有一个或多个 socket。这表明运输层有一个很重要的功能——复用 (multiplexing)和分用(demultiplexing)。</span></p><ul><li><strong><span>复用 (multiplexing): </span></strong><span>从多个 socket 接收来自多个进程的message，根据 socket 对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)，然后将报文段传递到网络层</span></li><li><strong><span>分用/解复用 (demultiplexing): </span></strong><span>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的socket (和对应的应用进程)。</span></li></ul><p><span>对接收到的报文进行差错检测。网络层的IP数据报首部中的检验和字段，只对首部差错进行检验。 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-16%20at%2022.52.03.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-16 at 22.52.03"></p><p><span>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</span></p><p>&nbsp;</p><h4 id='connectionless-demux'><span>Connectionless demux</span></h4><p><span>无连接(UDP)多路解复用</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2014.13.19.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 14.13.19"></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2014.15.59.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 14.15.59"></p><p>&nbsp;</p><h4 id='connection-oriented-demux'><span>Connection-oriented demux</span></h4><p><span>面向连接(TCP)的多路复用</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2014.03.19.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 14.03.19"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='33-connectionless-transport-udp'><span>3.3 connectionless transport: UDP</span></h3><p><span>UDP只在IP的数据报服务之上增加了很少一点的功能：</span></p><ul><li><span>复用和分用的功能</span></li><li><span>差错检测的功能，发现错误的就扔掉</span></li></ul><p><span>虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点。</span></p><p>&nbsp;</p><p><span>UDP 的主要特点 </span></p><ul><li><strong><span>connectionless:</span></strong><span> 发送数据之前不需要建立连接， 因此减少了开销和发送数据之前的时延。UDP发送端和接收端之间没有握手，每个UDP报文段都被 独立地处理</span></li><li><strong><span>best-effort:</span></strong><span> 尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</span></li><li><strong><span>面向报文:</span></strong><span> UDP对应用层交下来的报文， 既不合并，也不拆分，而是保留这些报文的边界。 UDP 一次交付一个完整的报文。</span></li><li><strong><span>没有拥塞控制:</span></strong><span> 因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。 很适合对时延要求较高的多媒体通信的要求。</span></li><li><strong><span>没有流量控制:</span></strong><span> 应用-&gt;传输的速率= 主机-&gt;网络的速率</span></li><li><u><strong><span>small header size:</span></strong><span> 只有8个字节，比TCP的20个字节的首部要短。</span></u></li><li><span>支持一对一、一对多、多对一和多对多的交互通信。</span></li></ul><p><span>发送方UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP就照样发送， 即一次发送一个报文。</span></p><p><span>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。</span></p><p><span>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。若报文太短，UDP 把它交给IP 层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2019.35.00.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 19.35.00"></p><p>&nbsp;</p><h4 id='udp-checksum'><span>UDP checksum</span></h4><p><strong><span>UDP checksum作用：确定当 UDP 报文段从源到达目的地移动时. 其中的比特是否发生了改变（只是检测错误，检测出来就丢弃这个报文，但是不能恢复这个报文）</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2017.26.50.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 17.26.50"></p><p><strong><span>Internet checksum: example 01</span></strong></p><p><span>注意:当数字相加时，在最高位的进位要回卷，再加到结果上（</span><strong><span>回卷 wraparound</span></strong><span>：前面溢出来的数，拉到最后再往上加）</span></p><p><span>目标端:校验范围+校验和=1111111111111111 通过校验，否则没有通过校验</span></p><p><span>注:求和时，必须将进位回卷到结果上</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2017.29.46.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 17.29.46"></p><p>&nbsp;</p><p><strong><span>Internet checksum: example 02</span></strong></p><p><span>假定我们有下面 3 个 16 比特的字:</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2019.47.17.png" alt="Screenshot 2023-02-17 at 19.47.17" style="zoom:53%;" /></p><ul><li><span>注意到最后一次加法有溢出，它要被回卷。</span></li><li><span>该和 0100101011000010 的反码运算结果是 1011010100111101 (反码运算就是将所有的 0 换成 1 所有的 1 转换成 0), 这就变为了检验和。 </span></li><li><span>在接收方，全部的4个16比特字(包括检验和) 加在一起，即 1011010100111101 (checksum) + 另外3个16比特字。</span></li><li><span>如果该分组中没有引入差错 ，则显然在接收方处该和将是1111111111111111。 如果这些比特有一个是 0, 那么我们就知道该分组中已经出现了差错 。</span></li></ul><p>&nbsp;</p><h3 id='34-principles-of-reliable-data-transfer'><span>3.4 principles of reliable data transfer</span></h3><p><span>可靠数据传输(rdt)的原理</span></p><p><span>数据的可靠传输是计算机网络中的通用概念，也是UDP和TCP的基石。计算机五层模型中，上层需要借助下层提供的功能来完成数据的传输，那么如果下层不可靠，我们该如何保证数据的可靠传输？</span></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2023.46.11.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 23.46.11"></p><p><strong><span>(b) service implementation</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2023.46.25.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 23.46.25"></p><ul><li><span>通过调用 rdt_send()函数，上层可以调用数据传输协议的发送方。它将要发送的数据可靠交付给位于接收方的较高层。</span></li><li><span>在接收端，当分组从信道的接收端到达时，将调用 rdt_rcv()。</span></li><li><span>当 rdt 协议想要向较高层交付数据时，将通过调用 deliver_data()来完成</span></li><li><span>除了交换含有待传送 的数据的分组之外，rdt 的发送端和接收端还需往返交换控制分组。rdt的发送端和接收端都要通过调用 udt_send()发送分组给对方</span></li></ul><p><span>接下来会一步步假设，一步步的暴露问题，来看看可靠性传输RDT是如何演进的？只考虑 单向数据传输 (unidirectional data transfer)。但控制信息是双向流动的 (But control info will flow on both directions) 因为有反馈机制。</span></p><p><span>有限状态机 (Finite-State Machine. FSM) 来描述发送方和接收方</span></p><p>&nbsp;</p><h4 id='rdt-10-all-reliable'><span>RDT 1.0 All reliable</span></h4><p><strong><span>scenario: 下层的信道是完全可靠的 (没有比特差错，没有分组丢失)</span></strong></p><p><span>发送方和接收方的FSM：发送方将数据发送到下层信道，接收方从下层信道接收数据</span></p><p><span>所以rdt1.0做的工作就是</span><u><span>封装和解封装</span></u></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2023.59.18.png" alt="Screenshot 2023-02-17 at 23.59.18" style="zoom:50%;" /></p><p>&nbsp;</p><h4 id='rdt-20-bit-errors'><span>RDT 2.0 Bit errors</span></h4><p><strong><span>scenario: 下层信道可能出现差错 (underlying channel may flip bits in packet 分组中的比特可能翻转, 0变为1, 1变为0)</span></strong></p><p><span>应对手段：</span></p><ul><li><p><strong><span>checksum:</span></strong><span> 用校验和的方式进行</span><u><span>差错检测</span></u><span> (error detection)</span></p></li><li><p><strong><span>feedback:</span></strong><span> send control msgs (ACK,NAK) from receiver to sender</span></p><ul><li><strong><span>acknowledgements (ACKs):</span></strong><span> 接收方显式的告诉发送方分组已经被接收 (no error scenario)</span></li><li><strong><span>negative acknowledgements (NAKs):</span></strong><span> 接收方显式地告诉发送方分组出现了差错 (error scenario, 发送方接收到NAK后，会重传分组)</span></li></ul></li></ul><p><strong><span>过程描述：</span></strong><span>发送方发送packet到下层信道，接收方接收，通过校验和发现数据有差错，返回NAK,发送方再次发送原packet；无差错返回ACK，发送方发送新的pactet。所以Rdt2.0新机制就是采用了差错控制编码进行差错检测</span></p><p><u><strong><span>stop and wait (停等协议):</span></strong><span> 发送方发送一个分组，然后等待接收方的应答。只有应答之后才会发送下一个分组。</span></u></p><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2016.55.15.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 16.55.15"></p><p><strong><span>存在问题 (fatal flaw):</span></strong><span> ACK/NAK分组也可能出错/受损</span></p><p><span>所以引出了 Rdt 2.1</span></p><p>&nbsp;</p><h4 id='rdt-21-acknak-corrupted'><span>RDT 2.1 ACK/NAK corrupted</span></h4><p><strong><span>scenario: 2.0 中接收方返回的 ACK/NAK 有可能出错，如果重传数据，还有可能重复。</span></strong></p><p><span>应对手段：</span></p><ul><li><strong><span>加上序号 (adds sequence number):</span></strong><span> 给每个packet加上序号，哪怕客户端接收到重复数据，也能判断到重复。（比如说， 我们想要传的第一组分组接受方返回了很模糊的信号，我们的发送方管他三七二十一就再次发送这个分组，并且标序号为0证明他是上一个的重复。接收方可以发现这次重复的分组，如果他之前的分组有错的话就直接替换，如果没有错的话就丢弃）</span></li><li><span>停止等待：发送方只发送一个分组，然后等待接收方的应答的方式称为停止等待协议</span></li></ul><p><strong><span>Sender:</span></strong></p><ul><li><span>在分组中加入序列号，两个序列号(0，1) 就足够了，一次只发送一个未经确认 的分组</span></li><li><span>必须检测ACK/NAK是否出错(需要EDC )</span></li><li><span>状态数变成了两倍，必须记住当前分组的序列号为0还是1</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2017.00.18.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 17.00.18"></p><p><strong><span>Receiver:</span></strong></p><ul><li><span>必须检测接收到的分组是否是重复的，状态会指示希望接收到的分组的序号为0还是1</span></li><li><span>但是 receiver 并不知道 sender 是否正确收到了其ACK/NAK</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2017.02.25.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 17.02.25"></p><ul><li><span>receiver 不知道它最后发送的 ACK/NAK 是否被正确地收到</span></li><li><span>sender 不对收到的 ACK/NAK 给确认，没有所谓的确认的确认;</span></li><li><span>比如，receiver 发送 ACK，如果后面 receiver 收到的是: 老分组p0，则 ACK 错误。下一个分组P1，ACK 正确</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2017.07.06.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 17.07.06"></p><p>&nbsp;</p><h4 id='rdt-22-nak-free-protocol'><span>RDT 2.2: NAK-free protocol</span></h4><p><strong><span>scenario: 发送方需要识别ACK和NACK两套状态管理，太复杂了</span></strong></p><p><span>应对手段：</span></p><p><span>●取消NACK：取消了NACK的方式，那么接收方怎么告诉发送方数据错了呢？可以通过返回ACK+上一个packet的序号的方式返回。</span></p><p><span>●重复ACK：当接收方收到重复的ACK时，说明下一个packet发送失败了。接收方会重发当前ACK序号后的报文</span></p><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2017.20.56.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 17.20.56"></p><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2017.21.35.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 17.21.35"></p><p><span>存在问题：返回的ACK也有可能丢失，发送方就会一直等待确认。</span></p><p><span>所以引出了 Rdt3.0</span></p><p>&nbsp;</p><h4 id='rdt-30-errors--loss'><span>RDT 3.0 Errors &amp; loss</span></h4><p><strong><span>scenario: 发送方会一直等待ACK，但是ACK有可能丢失，除了比特受损外 (Error)，底层信道还会丢包 (Loss)</span></strong></p><p><span>应对手段：</span></p><ul><li><strong><span>倒计数定时器 (countrlown timer):</span></strong><span> 对应时间内没收到ACK就直接触发超时重传机制 (认为可能传输过程中 loss 了). 发送端超时重传:如果到时没有收到ACK-&gt;重传 (链路层的timeout时间确定的, 传输层timeout时间是适应式的)</span></li></ul><p><span>存在问题：RDT3.0以及之前，一直采用停止等待协议，也就是一个包没收到响应就不会发送下一个，信道利用率太低。由此引入了流水线协议。</span></p><p><strong><span>sender:</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2021.37.00.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 21.37.00"></p><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2021.24.37.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 21.24.37"></p><ul><li><span>过早超时(延迟的ACK)也能够正常工作; 但是效率较低，一半的分组和确认是重复的;</span></li><li><span>设置一个合理的超时时间也是比较重要的;</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2021.25.12.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-18 at 21.25.12"></p><p>&nbsp;</p><p>&nbsp;</p><h4 id='rdt-30-stop-and-wait-operation'><span>RDT 3.0 stop-and-wait operation </span></h4><p><span>rdt3.0可以工作，但链路容量比较大的情况下，性能很差。链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</span></p><p><span>example:</span></p><ul><li><span>在这两个端系统之间的光速 </span><strong><span>往返传播时延RTT大约为30毫秒</span></strong><span>。</span></li><li><span>假设 ACK 分组很小(以便我们可以忽略其发送时间)，接收方一旦收到一个数据分组的最后 1 比特后立即发送 ACK</span></li><li><span>假定彼此通过一条</span><strong><span>发送速率R为 1 Gbps (每秒10^9比特)</span></strong><span>的信道相连 。 </span></li><li><span>包括首部字段和数据的</span><strong><span>分组长 L 为 1000 字节 (8000 比特)</span></strong><span>，发送一个分组进入 1 Gbps 链路实际所需时间是:</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2000.51.06.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 00.51.06"></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2000.50.44.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 00.50.44"></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2000.52.16.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 00.52.16"></p><p>&nbsp;</p><h4 id='rdt-30-pipelined-protocols'><span>RDT 3.0 Pipelined protocols </span></h4><p><strong><span>流水线协议 (Pipelined protocols):</span></strong><span> 为了提高信道的利用率，我们需要能够批量发送分组。当发送方窗口&gt;1,我们称之为流水线协议。</span></p><ul><li><p><strong><span>range of sequence numbers must be increased ([0,1] =&gt; [0, N-1])</span></strong><span>. 增加序号的范围，用多个bit表示分组的序号</span></p></li><li><p><span>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是 </span><strong><span>回退N步(Go-Back- N, GBN)</span></strong><span> 和 </span><strong><span>选择重传(Selective Repeat, SR)</span></strong></p></li><li><p><strong><span>buffering at sender and/or receiver.</span></strong><span> 在发送方/接收方要有缓冲区</span></p><ul><li><span>sender buffer: 缓冲那些已发送但没有确认的分组，可能需要重传</span></li><li><span>receiver buffer: 缓存那些巳正确接收的分组，上层用户取用数据的速率 ≠ 接收到的数据速率。接收到的数据可能乱序，排序交付(可靠)</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2002.08.23.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 02.08.23"></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2002.09.52.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 02.09.52"></p><p>&nbsp;</p><h5 id='gbn-go-back-n'><span>GBN (Go-Back-N)</span></h5><p><span>先明白一个概念 </span><strong><span>WS (window size)</span></strong><span> 代表可发送，或者可接收的窗口的长度。</span></p><ul><li><span>在 stop-and-wait operation 中，发送方只能发送一个分组，等待确认后，再发送下一个，所以：发送方窗口=1，接收方窗口=1。</span></li><li><span>但是在 Pipelined protocols 中的 GBN (Go-Back-N)，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口 。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为窗口长度 (window size) 。接收方窗口=1，发送方窗口=N。</span></li><li><span>GBN 协议也常被称为 </span><strong><span>滑动窗口协议 (sliding-window protocol)</span></strong><span> </span></li></ul><p>&nbsp;</p><h6 id='sending-window'><span>sending window</span></h6><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2002.21.28.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 02.21.28"></p><p><span>假设一开始没有发送任何一个分组, </span><strong><span>window size = 5</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2003.12.43.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 03.12.43"></p><p><strong><span>如果发送 packet 0 1 2 3 4, nextseqnum(前沿) 往后移5位:</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2003.13.01.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 03.13.01"></p><p><strong><span>收到 packet 0 的确认(ACK), send_base(后延) 往后移1位:</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2003.13.39.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 03.13.39"></p><p><strong><span>如果收到 packet 1 2 3 4 的确认(ACK), send_base(后延) 往后移4位:</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2003.18.41.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 03.18.41"></p><p>&nbsp;</p><h6 id='receiving-window'><span>receiving window</span></h6><p><span>接收窗口 (receiving window) = 接收缓冲区</span></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2012.32.49.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 12.32.49"></p><p>&nbsp;</p><ul><li><strong><span>sender sets timer for oldest in-flight pkt:</span></strong><span> 发送方只为最早的未经确认的分组维护一个定时器，如果产生超时，将重新发送该分组后的所有分组，也就是顾名思义的回退N步。</span></li><li><strong><span>discard (don’t buffer) out-of-order pkt 丢弃乱序:</span></strong><span> 接收方窗口只有1，如果接收到比较大的序号分组，都会选择丢弃。</span></li><li><strong><span>在接收端，乱序的不缓存</span></strong><span>。因此哪个n分组丢失了GB到那个分组n，即使n以后的分组传送都是正确的</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2002.27.48.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 02.27.48"></p><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2012.41.20.png" alt="Screenshot 2023-02-19 at 12.41.20" style="zoom:45%;" /></p><p>&nbsp;</p><h5 id='sr-selective-repeat'><span>SR (Selective Repeat)</span></h5><p><span>接收方窗口=N，发送方窗口=N。</span></p><ul><li><strong><span>sender maintains timer for each unacked packet:</span></strong><span> 发送方为</span><strong><span>每个分组</span></strong><span>都设置了重传定时器，发送方只重发那些没有收到 ACK 的packets. 接收方单独确认所有正确接收的 packets. </span></li><li><strong><span>out-of-order to buffer:</span></strong><span> 接收方可以乱序接收分组，当最头部分组整体接收完毕，滑动窗口可以整体后移。收到乱序分组可以缓存packets，以便最终 in-order delivery to upper layer (按顺序交付给上层)。也就是说，packet 有序：交给上层。无序：先缓存，等有序了再交给上层</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-19%20at%2012.29.55.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-19 at 12.29.55"></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2016.02.34.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 16.02.34"></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2015.41.22.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 15.41.22"></p><p>&nbsp;</p><h5 id='pipelined-summary'><span>Pipelined Summary</span></h5><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2015.16.31.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 15.16.31"></p><p><img src="Typora_Picture/Screenshot%202023-02-17%20at%2023.37.54.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-17 at 23.37.54"></p><p>&nbsp;</p><h3 id='35-connection-oriented-transport-tcp'><span>3.5 connection-oriented transport: TCP</span></h3><p><span>既然我们已经学习了可靠数据传输的基本原理，我们就可以转而学习 TCP 了。TCP 是因特网运输层的面向连接的可靠的运输协议。我们在本节中将看到，为了提供可靠数据传输，TCP依赖于前一节所讨论的许多基本原理、其中包括差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段。TCP 定义在 RFC 793、 RFC 1122、 RFC 1323、 RFC 2018 以及 RFC 2581 中。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2019.58.31.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 19.58.31"></p><p>&nbsp;</p><h4 id='tcp-segment-structure'><span>TCP segment structure</span></h4><p><span>与 UDP 一 样，TCP 首部包括源端口号和目的端口号 ，它被用于多路复用/分解来自或送到上层应用的数据。另外，同UDP一样，TCP 首部也包括</span><strong><span>检验和字段 (checksum field)</span></strong><span>。 TCP 报文段首部还包含下列字段 :</span></p><ul><li><p><strong><span>32 bits 的序号字段 (sequence number field):</span></strong><span> TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</span></p></li><li><p><strong><span>32 比特的确认号字段 (acknowl­ edgment number field): </span></strong><span>是期望收到对方的下一个报文段的数据的第一个字节的序号。</span></p></li><li><p><strong><span>16 bits 的接收窗口字段 (receive window field ):</span></strong><span> 该字段用于流量控制。作为接收方让发送方设置发送窗口的依据，单位为字节。窗口值经常在动态变化着，此字段明确指出现在允许对方发送的数据量。注意：不是滑动窗口的大小，滑动窗口的大小是固定的，他是用来记录接受缓冲区的大小，如果大小为0，就不会发送数据了。以此达到流量控制。</span></p></li><li><p><strong><span>4 bits 的首部长度字段 (header length field):</span></strong><span> 该字段指示了以 32 比特的字为单位的 TCP 首部长度。由于 TCP 选项字段的原因， TCP 首部的长度是可变的。(通常 选项字段为空 ，所以 TCP 首部的典 型长度是 20 字节)</span></p></li><li><p><strong><span>可选与变长的选项字段 (options field): </span></strong><span>该字段用于发送方与接收方 </span><strong><span>协商最大报文段长度 (MSS)</span></strong><span> 时，或在高速网络环境下用作窗口调节因子时使用 。 首部字段中还定义了一个时间戳选项。可参见 RFC 854 和 RFC 1323 了解其他细节。</span></p><ul><li><strong><span>MSS (Maximum Segment Size) 是TCP 报文段中的数据字段的最大长度。 数据字段加上TCP 首部才等于整个的TCP 报文段。 所以，MSS是“TCP 报文段长度减去TCP 首部长度。</span></strong></li></ul></li><li><p><strong><span>6 bits的标志字段 (flag field):</span></strong><span>  </span></p><ul><li><strong><span>紧急URG:</span></strong><span> 当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</span></li><li><strong><span>确认ACK:</span></strong><span> 只有当ACK =1时确认号字段才有效。当ACK =0 时，确认号无效。</span></li><li><strong><span>推送PSH (PuSH):</span></strong><span> 接收TCP收到 PSH =1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</span></li><li><strong><span>复位 RST (ReSeT):</span></strong><span> 当 RST=1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因 ），必须释放连接，然后再重新建立运输连接。</span></li><li><strong><span>同步SYN:</span></strong><span> 同步SYN=1表示这是一个连接请求或连接接受报文。 与ACK配合实现。</span></li><li><strong><span>终止FIN (FINish):</span></strong><span> 用来释放一个连接。FIN=1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</span></li></ul></li><li><p><span>所以，响应ACK = 请求SEQ + 请求字节数</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2020.02.58.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 20.02.58"></p><p>&nbsp;</p><h5 id='tcp-sequence-number-ack'><span>TCP sequence number, ACK</span></h5><ul><li><strong><span>TCP sequence number: </span></strong><span>segment 的第一个字节在 data stream 的编号，代表当前报文的发送序号。</span></li><li><strong><span>ACK:</span></strong><span> 期望从另一方收到的下一个字节的序号，累积确认。代表接收方需要的数据将从对方哪个序号开始。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2020.05.14.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 20.05.14"></p><h5 id='tcp序号和确认号之间的关系'><span>TCP序号和确认号之间的关系</span></h5><p><span>之前讲的都是单向传递，在这里 Telnet 是双向数据传递，互相发送数据和确认，两个互为接受方和发送方。</span></p><p><span>作为接收方a对上一次b发送的数据的确认。Seq是自己传给对方的字节流的数据开始点 (序号)，Ack是希望对方传给自己的字节流开始点 (确认号)。 客户端发出的每一个字符到了服务器，服务器要回转回来，然后客户端要给出相应的确认。</span></p><p><span>假设客户和服务器的起始序号分别是 42 和 79。 前面讲过，一个报文段的序号就是该 报文段数据字段首字节的序号 。 因此，客户发送的第一个报文段的序号为 42, 服务器发送的第一个报文段的序号为 79。 前面讲过，确认号就是主机正在等待的数据 的下一个字节序 号 。 在 TCP 连接建立后但没有发送任何数据之前，该客户等待字节 79, 而该服务器等待字节 42。</span></p><ul><li><p><span>Host A: </span></p><ul><li><span>在它的数据字段里包含一字节的字符 &#39;A&#39; 的 ASCII 码。</span></li><li><span>第一个报文段的序号字段里是 42。</span></li><li><span>另外，由于 A 还没有接收到来自 B 的任何数据，因此该第一个报文段中的确认号字段中是 79。即，当前的报文段数据是从第42个字节开始，希望从B那里获取从第79个字节开始的报文段</span></li></ul></li><li><p><span>Host B: </span></p><ul><li><span>首先它是为所收到数据提供一个确认，通过在确认号字段中填入 43, 告诉 A 它已经成功地收到 字节 42 及以前的所有字节，现在正等待着字节 43 的出现。</span></li><li><span>该报文段的第二个目的是回显字符&#39;B&#39;。因此，在第二个报文段的数据字段里填入的是字符 &#39;B&#39; 的 ASCII 码。</span></li><li><span>第二个报文段的序号为 79, 它是该 TCP 连接上从服务器到客户的数据流的起始序号，这也正是 B 要发送的第一个字节的数据。即，收到42。返回ACK43 (接收到了42号及以前的报文，希望从A那里获取从第43个字节开始的报文段), 并且发送第79个报文</span></li></ul></li><li><p><span>Host A: 该报文段的数据字段为空。收到79之后，返回ACK80，说我接受到了字节流中序号为 79 及以前的字节，希望你发送下一个从80开始的，并且发送第43个报文</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-18%20at%2021.43.01.png" alt="Screenshot 2023-02-18 at 21.43.01" style="zoom: 50%;" /></p><p>&nbsp;</p><h5 id='tcp-round-trip-time-timeout'><span>TCP round trip time, timeout</span></h5><ul><li><strong><span>Problem:</span></strong><span> TCP 和 rdt 协议一样采用超时/重传机制来处理报文段的丢失问题。但是问题就是定时器的超时时间设置。</span></li><li><strong><span>设置 timeout 的间隔必须 &gt; RTT</span></strong></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2022.17.18.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 22.17.18"></p><p>&nbsp;</p><h6 id='estimatedrtt'><span>EstimatedRTT</span></h6><ul><li><strong><span>SampleRTT:</span></strong><span> 比如发了50个报文，我抽取的5个报文作为SampleRTT进行统计。</span></li><li><strong><span>EstimatedRTT:</span></strong><span> SampleRTT的均值，一旦获得一个新 SampleR&#39;IT 时，TCP 就会根据下列公式来更新EstimatedRTT</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2023.06.26.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 23.06.26"></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2023.07.26.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 23.07.26"></p><p><span>EstimatedRTT 是 一个 SampleRIT 值的加权平均值。这个加权平均 对最近的样本赋予的权值要大于对旧样本赋予的权值。这是很自然的，因为越近的样本越能更好地反映网络的当前拥塞情况</span></p><p><span>从统计学观点讲，这种平均被称为 </span><strong><span>指数加权移动平均 (Exponential Weighted Moving Average, EWMA)</span></strong><span> 。 在 EWMA中的&quot;指数&quot;一词看起来是指一个给定的 SampleRTT 的权值在更新的过程中呈指数型快速衰减</span></p><p><span>下图显示了当 a= 1/8 时，在 gaia cs. umass. edu (在美国马萨诸塞州的 Amherst) 与 fantasia eurecom. fr (在法国南部)之间的 一 条 TCP 连接上的 SampleRTT 值与 Estimate­dRTT的值。显然SampleRTT 的变化在 EstimaLedRTT 的计算中趋于平缓了 。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2023.13.39.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 23.13.39"></p><p>&nbsp;</p><h6 id='devrtt'><span>DevRTT</span></h6><p><span>使用DevRTT的原因是我们想要一个更好的 safety margin</span></p><ul><li><span>除了估算RTT外，测量RTT的变化也是有价值的。</span></li><li><span>[RFC6298] 定义了 </span><strong><span>RTT偏差DevRTT</span></strong><span>, 用于估算 SampleRTT一般会偏离 EstimatedRTT 的程度:</span></li><li><span>就是先计算一个往返时间的估计值，在此基础上加上一个偏差范围的四倍，相当于计算了短时间内能覆盖99%以上情况的超时时间</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2023.19.42.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 23.19.42"></p><p>&nbsp;</p><h4 id='tcp-reliable-data-transfer'><span>TCP reliable data transfer</span></h4><p><span>TCP是一种流水线的传输方式，那么TCP属于GBN 还是属于SR呢，其实TCP是GBN和SR的混合体。</span></p><p><img src="Typora_Picture/Screenshot%202023-02-20%20at%2023.44.15.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-20 at 23.44.15"></p><p><img src="Typora_Picture/Screenshot%202023-02-21%20at%2000.00.47.png" referrerpolicy="no-referrer" alt="Screenshot 2023-02-21 at 00.00.47"></p><ul><li><span>顺序接收：因为有了分组编号，接收方收到乱序的分组后，不会选择丢弃，而是缓存起来，排好序。返回的ACK仍然是第一个未收到的分组序号。</span></li><li><span>超时重传：tcp发送方只为最早的分组设置一个定时器，当分组未收到ACK触发超时重传，并获得ACK应答后，才开始为下一个未确认分组开始计时。</span></li><li><span>选择确认：发送方未接收到分组的ACK时，只会重新发送单个分组，而不会发送所有分组。</span></li></ul><p>&nbsp;</p><h5 id='tcp-retransmission-scenarios'><span>TCP: retransmission scenarios</span></h5><p><img src="Typora_Picture/Screenshot%202023-03-08%20at%2013.26.16.png" alt="Screenshot 2023-03-08 at 13.26.16" style="zoom:40%;" /></p><p><img src="Typora_Picture/Screenshot%202023-03-08%20at%2013.26.27.png" alt="Screenshot 2023-03-08 at 13.26.27" style="zoom:40%;" /></p><p>&nbsp;</p><h5 id='tcp-fast-retransmit'><span>TCP fast retransmit</span></h5><p><span>快速重传 (TCP fast retransmit)：基于接收方ACK确认机制，ACK序号为按顺序第一个未收到的分组。</span><strong><span>发送方接收到三次相同的ACK序号后，会触发快速重传机制</span></strong><span>，重传ACK序号标识的分组。</span></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.18.15.png" alt="Screenshot 2023-03-17 at 13.18.15" style="zoom:40%;" /></p><p>&nbsp;</p><p>&nbsp;</p><h4 id='tcp-flow-control'><span>TCP flow control</span></h4><ul><li><p><span>一般来说，我们总是希望数据传输得更快一些</span></p></li><li><p><span>但如果</span><strong><span>发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</span></strong></p></li><li><p><span>所谓</span><strong><span>流量控制(flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收</span></strong></p></li><li><p><span>利用</span><strong><span>滑动窗口机制 (rwnd) </span></strong><span>可以很方便地在TCP连接上实现对发送方的流量控制。</span></p><ul><li><span>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</span></li><li><span>TCP发送方收到接收方的 rwnd = 0 通知后，应启动持续计时器。持续计时器超时后，向接收方发送 rwnd 探测报文。</span></li></ul></li><li><p><span>TCP发送方的发送窗口 = min {自身拥塞窗口，TCP接收方的接收窗口}</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.45.18.png" alt="Screenshot 2023-03-17 at 13.45.18" style="zoom:30%;" /></p><p><strong><span>Example:</span></strong></p><p><span>initial 发送窗口 = 400, -&gt; initial rwnd = 400</span></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.29.26.png" alt="Screenshot 2023-03-17 at 13.29.26" style="zoom:50%;" /></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.30.39.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-17 at 13.30.39"></p><p><span>TCP发送方收到接收方的 rwnd = 0 通知后，应启动持续计时器。持续计时器超时后，向接收方发送 rwnd 探测报文。</span></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.31.30.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-17 at 13.31.30"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='36-tcp-congestion-control'><span>3.6 TCP congestion control</span></h3><p><span>有时，发送方和接收方性能后很好，结果是中途的网络带宽不行，网络中堵塞了。这时候如果还是依然大量的发送消息，反而会造成更大面积的网络拥塞。</span></p><ul><li><p><span>manifestations (表现为):</span></p><ul><li><span>lost packets (buffer overflow at routers) 丢包 (路由器缓冲区溢出)</span></li><li><span>long delays (queueing in router buffers) 长时间延迟 (在路由器缓冲区排队)</span></li></ul></li></ul><h4 id='tcp-tahoe'><span>TCP Tahoe</span></h4><ul><li><span>slow-start</span></li><li><span>congestion avoidance</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.34.43.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-17 at 13.34.43"></p><p>&nbsp;</p><h4 id='tcp-reno'><span>TCP Reno</span></h4><ul><li><span>fast retransmit</span></li><li><span>fast recovery</span></li></ul><p><span>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。这将导致发送方超时重传，并误认为网络发生了拥塞，发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。</span></p><ul><li><p><span>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</span></p></li><li><p><span>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</span></p><ul><li><span>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</span></li><li><span>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</span></li><li><span>发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</span></li></ul></li></ul><p><span>之前的例子中，当拥塞窗口值 cwnd = 24 时发生了超时重传，而此时网络并没有发生拥塞，但是发送方却误认为网络发生了拥塞，于是发送方把拥塞窗口 cwnd 减少到 1，并错误的启动慢开始算法，降低了传输效率。</span></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.38.47.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-17 at 13.38.47"></p><p>&nbsp;</p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2013.42.38.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-17 at 13.42.38"></p><p>&nbsp;</p><h2 id='04-network-data-plane-端到端'><u><span>04. Network (Data Plane) 端到端</span></u></h2><p><span>Network layer 将 段(segment) 从一台发送主机移动到一台接收主机，是</span><strong><span>主机之间的逻辑通信</span></strong><span>，能够被分解为两个相互作用的部分，即 </span><strong><span>data plane (数据平面)</span></strong><span> 和 </span><strong><span>control plane (控制平面)</span></strong></p><p><span>Two key network-layer functions:</span></p><ul><li><span>forwarding: 将分组从路由器的输入接口转发到合适的输出接口，通过单个路口的过程。就是说从不同的端口收来的分组，然后通过合适的端口打出去。是局部功能（转发是在数据平面中实现的唯一功能）</span></li><li><span>routing: 使用路由算法来决定分组从发送主机到目标接收主机的路径，从出发地到目的地的行程规划过程。是全局功能。（路由选择在网络层的控制平面中实现）</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2000.27.49.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 00.27.49"></p><p><img src="Typora_Picture/Screenshot%202023-03-17%20at%2023.54.53.png" alt="Screenshot 2023-03-17 at 23.54.53" style="zoom:40%;" /></p><p>&nbsp;</p><h3 id='41-overview-of-network-layer'><span>4.1 Overview of network layer</span></h3><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2000.38.12.png" alt="Screenshot 2023-03-18 at 00.38.12" style="zoom:50%;" /></p><h4 id='data-plane'><span>data plane</span></h4><ul><li><p><span>本地，每个路由器功能</span></p></li><li><p><span>确定到达路由器输入端口的 datagram 如何 </span><strong><span>forward</span></strong><span> 到路由器输出端口</span></p></li><li><p><span>转发功能:</span></p><ul><li><span>传统方式：基于目标地址 + 转发表</span></li><li><span>SDN方式：基于多个字段 + 流表</span></li></ul></li></ul><p><img src="Typora_Picture/image-20230318002806489.png" alt="image-20230318002806489" style="zoom:60%;" /></p><p>&nbsp;</p><h4 id='control-plane'><span>control plane</span></h4><ul><li><p><span>network-wide logic (网络范围内的逻辑)</span></p></li><li><p><span>确定 datagram 如何沿着从源主机到目标主机的 end-to-end 路径在路由器之间路由</span></p></li><li><p><span>two control-plane approaches:</span></p><ul><li><p><strong><span>traditional routing algorithms(Per-router):</span></strong><span> implemented in routers (在路由器中实现)</span></p><p><span>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2000.31.28.png" alt="Screenshot 2023-03-18 at 00.31.28" style="zoom:40%;" /></p></li><li><p><strong><span>software-defined networking (SDN):</span></strong><span> implemented in (remote) servers (在远程的服务器中实现)</span></p><p><span>一个不同的 (通常是远程的) controller interacts with local control agents (CAs) </span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2000.34.44.png" alt="Screenshot 2023-03-18 at 00.34.44" style="zoom:45%;" /></p></li></ul></li></ul><p>&nbsp;</p><h3 id='42-whats-inside-a-router'><span>4.2 What’s inside a router </span></h3><p><span>Router architecture overview (路由器体系架构):</span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2016.02.35.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 16.02.35"></p><p>&nbsp;</p><h4 id='input-port-functions'><span>Input port functions:</span></h4><ul><li><p><span>link layer 把frame当中的数据部分提取出来数据部分 (可能是一个IP的分组) </span></p></li><li><p><span>交给 network layer 实体中的队列 (</span><strong><span>queuing</span></strong><span>: if datagrams arrive faster than forwarding rate into switch fabric (queueing delay and loss due to input buffer overflow))</span></p></li><li><p><span>排到对头后按照路由处理器交下来的路由表，找到合适的端口，把它放出去 (</span><strong><span>根据 header field values</span></strong><span>，使用输入端口内存中的转发表查找输出端口(“匹配+动作”))，</span><strong><span>完成输入端口处理</span></strong></p><ul><li><strong><span>destination-based forwarding (传统转发方式):</span></strong><span> 根据 datagram 头部的目标IP地址，来查路由表转发</span></li><li><strong><span>generalized forwarding (SDN):</span></strong><span> 查这个分组的多个层面的头部信息，匹配相应流表的字段，然后找到匹配的流表来action</span></li></ul></li><li><p><span>通过fabric做一个局部的交换，从输入端口转到输出端口。</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2017.04.21.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 17.04.21"></p><h4 id='input-port-queuing'><span>Input port queuing</span></h4><p><span>所以分组有可能会因为其他分组正在输出同一个端口等待而导致堵塞，如果一直堵着有可能会造成丢失</span></p><p><span>所以说 network layer 输入端口缓存的目的就是为了匹配瞬间的输入速率和输出速率的不一致性，需要一个queue来匹配不一致性</span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2017.49.58.png" alt="Screenshot 2023-03-18 at 17.49.58" style="zoom:40%;" /></p><p>&nbsp;</p><h4 id='switching-fabrics'><span>Switching fabrics</span></h4><ul><li><p><span>然后我们来看一下</span><strong><span>fabric</span></strong><span>怎么样 </span><strong><span>将 packet 从 input buffer 传输到合适的 output buffer</span></strong></p></li><li><p><strong><span>switching rate:</span></strong><span> 分组可以按照 switching rate 从输入传输到输出</span></p><ul><li><span>运行速度经常是输入/输出链路速率的</span><strong><span>若干倍</span></strong><span>，如果有N 个输入端口，交换机构的  switching rate 必须是输入线路速度的N倍，才不会成为瓶颈</span></li></ul></li><li><p><span>有三种常见的fabric的工作模式:</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2017.58.08.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 17.58.08"></p><h5 id='switching-via-memory'><span>Switching via memory</span></h5><ul><li><p><span>第一代路由器就是在CPU直接控制下的交换，采用传统的计算机</span></p></li><li><p><span>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</span></p></li><li><p><span>Problems:</span></p><ul><li><span>转发速率被内存的带宽限制 (</span><strong><span>datagram 通过BUS两遍</span></strong><span>)，所以 系统总线(bus) 本身就会成为fabric交换速度的瓶颈，带宽每分钟交换或者是转发分组的速率很低</span></li><li><span>一次只能转发一个分组</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2018.07.48.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 18.07.48"></p><p>&nbsp;</p><h5 id='switching-via-a-bus'><span>Switching via a bus</span></h5><ul><li><p><span>datagram 只要通过一次 share bus (共享总线，不是系统总线)，从输入端口转发到输出端口</span></p></li><li><p><span>Problem:</span></p><ul><li><span>bus contention (总线竞争): 交换速度受限于总线带宽</span></li><li><span>1次处理一个分组</span></li><li><span>对于接入或企业级路由器速度足够 (但不适合区域或骨干网络)</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2018.16.52.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 18.16.52"></p><p>&nbsp;</p><h5 id='switching-via-interconnection-network'><span>Switching via interconnection network</span></h5><ul><li><span>通过互联网络 (Banyan, crossbar等) 的交换，将多个处理器连接成多处理器，同时并发转发多个分组，克服总线带宽限制</span></li><li><span>当分组从左上角端口到达，转给下面端口; 控制器短接相应的两个总线</span></li><li><span>advanced design: 将数据报分片为</span><strong><span>固定长度的信元</span></strong><span>，通过交换网络交换</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2018.21.11.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 18.21.11"></p><p>&nbsp;</p><h4 id='destination-based-forwarding-传统转发方式'><span>destination-based forwarding (传统转发方式):</span></h4><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2017.28.41.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 17.28.41"></p><h5 id='longest-prefix-matching-最长前缀匹配'><span>Longest prefix matching 最长前缀匹配</span></h5><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2017.36.00.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 17.36.00"></p><p>&nbsp;</p><h4 id='output-ports--queueing'><span>Output ports &amp; queueing</span></h4><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2018.54.51.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 18.54.51"></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2019.03.13.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 19.03.13"></p><p>&nbsp;</p><h3 id='43-ip-internet-protocol'><span>4.3 IP: Internet Protocol</span></h3><h4 id='ipv4-addressing'><span>IPv4 addressing</span></h4><p><strong><span>IP = 网络号＋主机号</span></strong><span>，IP 地址具有以下结构： </span></p><ul><li><strong><span>subnet part (网络号，子网部分):</span></strong><span> devices in same subnet have common </span><strong><span>high order bits</span></strong></li><li><strong><span>host part (主机号，主机部分):</span></strong><span> remaining </span><strong><span>low order bits</span></strong><span> </span></li></ul><p><span>首先要知道的是 IP地址 不能标识主机 或者 路由器本身，而是一个 </span><strong><span>interface (接口)</span></strong><span>，主机/路由器上的链路层接口</span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2019.13.50.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 19.13.50"></p><h4 id='subnets'><span>Subnets</span></h4><ul><li><span>不需要经过 intervening router (中间的路由器)，就可以物理上相互到达的 device interfaces (设备接口)</span></li><li><span>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</span></li><li><span>IP 地址 = {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2022.11.04.png" alt="Screenshot 2023-03-18 at 22.11.04" style="zoom:40%;" /></p><p><span>/24 代表前面24位，高位的24位是网络号，意味着后面8位数是主机号</span></p><p><img src="Typora_Picture/Screenshot%202023-03-18%20at%2022.13.07.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-18 at 22.13.07"></p><p>&nbsp;</p><h4 id='ip-datagram-format'><span>IP Datagram format</span></h4><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.14.18.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 00.14.18"></p><p>&nbsp;</p><h4 id='ip-分片和重组fragmentation--reassembly'><span>IP 分片和重组(Fragmentation &amp; Reassembly)</span></h4><ul><li><p><strong><span>网络链路有MTU (最大传输单元)</span></strong><span> –链路层帧所携带的最大数据长度</span></p><center>
  <img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.34.11.png" alt="Screenshot 2023-03-19 at 00.34.11" style="zoom:50%;">
  <img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.36.47.png" alt="Screenshot 2023-03-19 at 00.36.47" style="zoom:50%;"></center></li><li><p><span>不能直接分片</span></p><ul><li><span>分片后加上头部，相同的ID</span></li><li><span>offset (偏移量) 当作序号，第一个分组的 offset = 0，第二个分组的 offset = 1480bits = 185Bytes，第二个分组的 offset = 2960bit = 370Bytes</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.40.37.png" alt="Screenshot 2023-03-19 at 00.40.37" style="zoom:50%;" /></p><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.46.10.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 00.46.10"></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2000.31.29.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 00.31.29"></p><p>&nbsp;</p><h4 id='host如何获得一个ip地址'><span>Host如何获得一个IP地址?</span></h4><p><span>两种方法:</span></p><ul><li><p><strong><span>config file:</span></strong><span> 系统管理员将地址配置在一个文件中</span></p><ul><li><span>Wintel: control-panel -&gt; network -&gt; configuration -&gt; tcp/ip -&gt; properties</span></li><li><span>UNIX: /etc/rc.config</span></li></ul></li><li><p><strong><span>DHCP:</span></strong><span> Dynamic Host Configuration Protocol: 从服务器中动态获得一个IP地址 (plug-and-play)</span></p></li></ul><p>&nbsp;</p><h4 id='dhcp-dynamic-host-configuration-protocol-udp'><span>DHCP: Dynamic Host Configuration Protocol (UDP)</span></h4><ul><li><p><span>以便使用DHCP分配即插即用IP地址，网络将需要有一个DHCP服务器来执行该功能</span></p></li><li><p><span>当有一个客户端出现，他是一个想要IP地址的主机，将从DHCP服务器请求并接收IP地址，使用DHCP协议。</span></p></li><li><p><span>当主机离开网络时，他会放弃他的IP地址，然后可以被另一个主机重用或回收，或者可能由该主机在以后的时间点续订。</span></p></li><li><p><strong><span>作用: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址</span></strong></p><ul><li><span>可以更新对主机在用IP地址的租用期-租期快到了</span></li><li><span>重新启动时，允许重新使用以前用过的IP地址</span></li><li><span>支持移动用户加入到该网络(短期在网)</span></li></ul></li></ul><p>&nbsp;</p><p><span>通常DHCP服务器将配置在路由器中，并为该路由器所连接的所有子网提供服务</span></p><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2017.03.16.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 17.03.16"></p><p>&nbsp;</p><h5 id='4-important-dhcp-message-overview'><span>4 important DHCP message overview:</span></h5><ul><li><u><span>host broadcasts (主机广播): </span><strong><span>DHCP discover message</span></strong></u><span> [optional] （广播：DHCP server在那里嘛）</span></li><li><u><span>DHCP server responds (DHCP服务器提供报文相应): </span><strong><span>DHCP offer message</span></strong></u><span> [optional] （我是DHCP server，这是你可以用的IP）</span></li><li><u><span>host requests IP address (主机请求IP地址): </span><strong><span>DHCP request message </span></strong></u><span> （好的，我接受这个IP地址）</span></li><li><u><span>DHCP server sends address (DHCP服务器发送地址): </span><strong><span>DHCP ack message</span></strong></u><span> （好的，你现在拥有这个IP地址）</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2017.26.04.png" alt="Screenshot 2023-03-19 at 17.26.04" style="zoom:40%;" /></p><h5 id='dhcp-不仅仅可以返回ip-addresses'><span>DHCP: 不仅仅可以返回IP addresses</span></h5><ul><li><span>DHCP can return allocated </span><strong><span>IP address</span></strong><span> on subnet (可以返回IP地址)</span></li><li><strong><span>address of first-hop router</span></strong><span> for client (第一跳路由器的IP地址)</span></li><li><strong><span>name and IP address of DNS sever</span></strong><span> (DNS服务器的域名和IP地址)</span></li><li><strong><span>network mask</span></strong><span> (子网掩码，为了划分网络号和主机号的)</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2021.09.46.png" alt="Screenshot 2023-03-19 at 21.09.46" style="zoom:30%;" /></p><p>&nbsp;</p><h4 id='一个isp如何获得一个地址块'><span>一个ISP如何获得一个地址块?</span></h4><p><strong><span>ICANN: Internet Corporation for Assigned Names and Numbers</span></strong></p><ul><li><span>分配 addresses</span></li><li><span>管理 DNS</span></li><li><span>分配 domain names，解决冲突</span></li></ul><p>&nbsp;</p><h2 id='05-network-control-plane'><u><span>05. Network (Control Plane)</span></u></h2><p><span>我们将关注单个路由器在每个路由器函数的数据平面中到更广泛的网络视图，研究路由问题，比如说如何确定从原地址到目的地，我们还将研究网络管理和网络配置的问题。</span></p><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2021.24.40.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 21.24.40"></p><p>&nbsp;</p><h3 id='51-intro-control-plane'><span>5.1 Intro: control plane</span></h3><p><span>2 种构建 network control plane 的方法:</span></p><ul><li><span>per-router control (traditional)</span></li><li><span>logically centralized control (software defined networking)</span></li></ul><p>&nbsp;</p><h3 id='52-routing-protocols'><span>5.2 routing protocols</span></h3><ul><li><strong><span>routing:</span></strong><span> 路由就是计算从一个网络到其他网络如何走的问题，按照某种指标 (传输延迟,所经过的站点数目等) 找到一条从源节点到目标节点的较好路径</span></li><li><span>任何路由算法的目标都是确定一条好的路径或一条好的路由:</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2021.37.28.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 21.37.28"></p><p><img src="Typora_Picture/Screenshot%202023-03-19%20at%2022.09.35.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-19 at 22.09.35"></p><p>&nbsp;</p><h4 id='routing-algorithm-classification'><span>Routing algorithm classification</span></h4><p><span>Routing algorithm 分为 Static or Dynamic，也可以分为 Global or Decentralized.</span></p><p><span>尽管它们有相同的共同目标，即计算最短路径，最小成本路径，但他们实际上计算最短路径的方式不一样:</span></p><ul><li><strong><span>Static</span></strong><span>: routes change </span><strong><span>slowly</span></strong><span> over time</span></li><li><strong><span>Dynamic</span></strong><span>: routes change more </span><strong><span>quickly</span></strong><span>，周期性更新，根据链路代价的变化而变化</span></li><li><strong><span>Global/centralized</span></strong><span>: all routers 拥有完整的拓扑(topology) 和边(link)的代价的信息，算法必须知道网络中每个链路的成本 (</span><strong><span>&quot;link state&quot;</span></strong><span> algorithms)</span></li><li><strong><span>Decentralized</span></strong><span>: 路由器只知道与它有物理连接关系的邻居路由器，路由器以迭代、分布式的方式计算出最低开销路径 。 没有节点拥有关于所有网络链路开销的完整信息 (</span><strong><span>&quot;distance vector&quot;</span></strong><span> algorithms)</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2011.14.21.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-20 at 11.14.21"></p><p>&nbsp;</p><h4 id='521-link-state-dijkstra'><span>5.2.1 Link state (Dijkstra)</span></h4><p><strong><span>缺点:</span></strong><span> Dijkstra算法起初选了一个最优的path，于是都用这个path传，最后会导致这个path的堵塞，Dijkstra算法就会继续选择另一个最优的path......一直这样反反复复，切换path的行为就叫做路径的振荡</span></p><p><span>Dijkstra’s link-state routing algorithm</span></p><ul><li><p><span>链路状态算法中，每个结点 (经广播) 与所有其他结点交谈，但它仅告诉它们与它直接相连链路的费用。</span></p></li><li><p><strong><span>centralized</span></strong><span>: network </span><strong><span>topology</span></strong><span>, </span><strong><span>所有节点都知道每个链路的成本</span></strong><span>，通过“link state broadcast” 实现，</span><strong><span>所有节点具有相同信息</span></strong></p></li><li><p><strong><span>computes least cost paths</span></strong><span> from one node (“source”) to all other nodes</span></p><ul><li><span>gives </span><strong><span>forwarding table</span></strong><span> for that node</span></li></ul></li><li><p><strong><span>iterative</span></strong><span>: after </span><em><span>k</span></em><span> iterations, know least cost path to </span><em><span>k</span></em><span> destinations</span></p></li></ul><p><span>2类节点:</span></p><ul><li><strong><span>临时节点(tentative node):</span></strong><span> 还</span><strong><span>没有</span></strong><span>找到从源节点到此节点的最优路径的节点</span></li><li><strong><span>永久节点(permanent node) N’:</span></strong><span>已经</span><strong><span>找到了</span></strong><span>从源节点到此节点的最优路径的节点</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2011.58.33.png" alt="Screenshot 2023-03-20 at 11.58.33" style="zoom:40%;" /></p><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2022.52.56.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-20 at 22.52.56"></p><p><strong><span>algorithm complexity</span></strong><span>: n nodes, each iteration needs to check all nodes, w, not in N’, n(n+1)/2 comparisons: O(n2)</span></p><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2014.19.50.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-20 at 14.19.50"></p><h5 id='examples-01'><em><span>Examples 01</span></em></h5><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2023.38.55.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-20 at 23.38.55"></p><h5 id='examples-02'><em><span>Examples 02</span></em></h5><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2012.24.15.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 12.24.15"></p><h5 id='examples-03'><em><span>Examples 03</span></em></h5><p><img src="Typora_Picture/Screenshot%202023-03-20%20at%2023.31.13.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-20 at 23.31.13"></p><p>&nbsp;</p><h5 id='examples-04'><em><span>Examples 04</span></em></h5><p><span>Consider the network below. Please use Dijkstra’s shortest-path algorithm to compute the shortest path from node </span><em><span>h</span></em><span> to all network nodes.</span></p><center>
  <img src="Typora_Picture/image-20230330232945016.png" alt="image-20230330232945016" style="zoom:80%;">
  <img src="Typora_Picture/Screenshot%202023-03-30%20at%2023.47.52.png" alt="Screenshot 2023-03-30 at 23.47.52" style="zoom:40%;">
  <img src="Typora_Picture/Screenshot%202023-03-31%20at%2001.10.53.png" alt="Screenshot 2023-03-31 at 01.10.53" style="zoom:50%;"></center><figure><table><thead><tr><th><span>Step</span></th><th><span>N&#39;</span></th><th><span>D(f),p(f)</span></th><th><span>D(g),p(g)</span></th><th><span>D(e),p(e)</span></th><th><span>D(c),p(c)</span></th><th><span>D(d),p(d)</span></th><th><span>D(b),p(b)</span></th><th><span>D(a),p(a)</span></th></tr></thead><tbody><tr><td><span>0</span></td><td><span>h</span></td><td><strong><span>2,h</span></strong></td><td><span>5,h</span></td><td><span>infinite</span></td><td><span>infinite</span></td><td><span>infinite</span></td><td><span>infinite</span></td><td><span>infinite</span></td></tr><tr><td><span>1</span></td><td><span>hf</span></td><td>&nbsp;</td><td><strong><span>5,h</span></strong></td><td><span>infinite</span></td><td><span>infinite</span></td><td><span>infinite</span></td><td><span>10,f</span></td><td><span>infinite</span></td></tr><tr><td><span>2</span></td><td><span>hfg</span></td><td>&nbsp;</td><td>&nbsp;</td><td><span>13,g</span></td><td><span>infinite</span></td><td><strong><span>9,g</span></strong></td><td><span>10,f</span></td><td><span>infinite</span></td></tr><tr><td><span>3</span></td><td><span>hfgd</span></td><td>&nbsp;</td><td>&nbsp;</td><td><span>13,g</span></td><td><span>15,d</span></td><td>&nbsp;</td><td><strong><span>10,f</span></strong></td><td><span>infinite</span></td></tr><tr><td><span>4</span></td><td><span>hfgdb</span></td><td>&nbsp;</td><td>&nbsp;</td><td><span>13,g</span></td><td><span>15,d</span></td><td>&nbsp;</td><td>&nbsp;</td><td><strong><span>12,b</span></strong></td></tr><tr><td><span>5</span></td><td><span>hfgdba</span></td><td>&nbsp;</td><td>&nbsp;</td><td><strong><span>13,g</span></strong></td><td><span>14,a</span></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><span>6</span></td><td><span>hfgdbae</span></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td><strong><span>14,a</span></strong></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td><span>7</span></td><td><span>hfgdbaec</span></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h4 id='522-distance-vector-bellman-ford-equation'><span>5.2.2 Distance vector (Bellman-Ford equation)</span></h4><ul><li><span>距离向量算法中，</span><strong><span>每个结点</span></strong><span>仅与它的</span><strong><span>直接相连的邻居交谈</span></strong><span>，但它为其邻居提供了从它自己到网络中 (它所知道的) 所有其他结点的最低费用估计。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-21%20at%2013.46.58.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-21 at 13.46.58"></p><p><img src="Typora_Picture/Screenshot%202023-03-21%20at%2013.58.21.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-21 at 13.58.21"></p><p><img src="Typora_Picture/Screenshot%202023-03-21%20at%2014.17.34.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-21 at 14.17.34"></p><p><img src="Typora_Picture/Screenshot%202023-03-21%20at%2022.21.34.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-21 at 22.21.34"></p><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2000.43.36.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 00.43.36"></p><p>&nbsp;</p><h5 id='distance-vector-link-cost-changes'><span>Distance vector: link cost changes</span></h5><p><span>在 Distance vector 中，当节点检测到本地链路开销变化，更新路由信息，重新计算 distance vector，如果DV发生变化，通知邻居</span></p><p><strong><span>&quot;good news travels fas&quot;</span></strong></p><ul><li><span>t0: y检测链路开销变化，更新DV，通知邻居。</span></li><li><span>t1: z接收y的更新，更新它的表，计算新的最小代价到x，将它的DV发送给它的邻居。</span></li><li><span>T2: y接收z的更新，更新它的距离表。Y的最小代价不变，所以Y不会向z发送消息。</span></li></ul><p>&nbsp;</p><p><strong><span>&quot;bad news travels slow&quot; – count-to-infinity problem:</span></strong></p><ul><li><span>many iterations before algorithm stabilizes</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2000.55.10.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 00.55.10"></p><p>&nbsp;</p><h4 id='523-link-state--distance-vector-算法的比较'><span>5.2.3 Link State &amp; Distance Vector 算法的比较</span></h4><ul><li><strong><span>Link State:</span></strong><span> 需要全局信息。因此，当在每台路由器中实现时，每个节点(经广播)与所有其他节点通信，但仅告诉它们与它直接相连链路的开销。我们通过快速比较它们各自的属性来总结所学的链路状态与距离向量算法。（会有振荡: oscillations）</span></li><li><strong><span>Distance Vector:</span></strong><span> 每个节点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自已到网络中(它所知道的)所有其他节点的最低开销估计。</span></li><li><span>记住 N 是节点(路由器)的集合，而 E 是边(链 路)的集合 。</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2000.46.05.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 00.46.05"></p><p>&nbsp;</p><h3 id='53-intra-as-routing'><span>5.3 intra-AS routing</span></h3><p><span>Making routing scalable:</span></p><ul><li><strong><span>scale:</span></strong><span> 拥有数十亿个目的地，不能将所有目的地存储在路由表中!</span></li><li><strong><span>administrative autonomy:</span></strong><span> 因特网=网络中的网络，每个网络管理员可能都想控制自己网络中的路由。因特网是 ISP 的网络，其中每个 ISP 都有它自己的路由器网络。ISP 通常希望按自己的意愿运行路由器。一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来 。</span></li></ul><p><span>这两个问题都可以通过将路由器组织进 </span><strong><span>自治系统 (Autonomous System , AS)</span></strong><span> 来解决。</span></p><ul><li><span>其中每个 </span><strong><span>Autonomous System</span></strong><span> 由一组通常处在相同管理控制下的路由器组成。</span></li><li><span>通常在一个ISP中的路由器以及互联它们的链路构成一个 </span><strong><span>Autonomous System</span></strong></li><li><span>然而，某些 ISP 将它们的网络划分为多个 </span><strong><span>Autonomous System</span></strong><span>。特别是某些一级 ISP 在其整个网络中使用一个庞大的 </span><strong><span>Autonomous System</span></strong><span>, 而其他 ISP 则将它们的 ISP 拆分为数十个互联的  </span><strong><span>Autonomous System</span></strong></li><li><span>一个自治系统由其全局唯一的 </span><strong><span>自治系统 (Autonomous System , AS)</span></strong><span>号 (ASN) 所标识 [RFC1930]。就像IP 地址那样，AS 号由 ICANN 区域注册机构所分配 [ICANN 2016] 。</span></li></ul><h4 id='internet-approach-to-scalable-routing'><span>Internet approach to scalable routing</span></h4><p><span>将 routers 聚合到称为 </span><strong><span>&quot;autonomous systems&quot; (AS)</span></strong><span> 的区域 (又名 &quot;domains&quot;)</span></p><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2014.18.01.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 14.18.01"></p><p>&nbsp;</p><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2016.02.04.png" alt="Screenshot 2023-03-22 at 16.02.04" style="zoom: 50%;" /></p><center>
  <img src="Typora_Picture/Screenshot%202023-03-22%20at%2016.02.19.png" alt="Screenshot 2023-03-22 at 16.02.19" style="zoom:49%;">
  <img src="Typora_Picture/Screenshot%202023-03-22%20at%2016.02.32.png" alt="Screenshot 2023-03-22 at 16.02.32" style="zoom:49%;">
</center><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2016.07.24.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 16.07.24"></p><p>&nbsp;</p><h3 id='54-three-intra-domain-routing-protocols'><span>5.4 Three intra domain routing protocols</span></h3><h4 id='rip'><span>RIP</span></h4><p><span>RIP: Routing Information Protocol [RFC 1723] (Distance vector 算法)</span></p><ul><li><span>在 1982年发布的BSD-UNIX 中实现</span></li><li><span>distance metric: # hops (max = 15 hops)，每条 link cost = 1</span></li><li><span>DV每隔30秒和邻居交换一次DV in response message (advertisement 通告) </span></li><li><span>每个 advertisement 包括: 最多25个 destination subnets (in IP addressing sense)</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2018.20.29.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 18.20.29"></p><p>&nbsp;</p><h4 id='ospf-ls'><span>OSPF (LS)</span></h4><p><span>OSPF: Open Shortest Path First [RFC 2328]</span></p><ul><li><p><strong><span>&quot;open&quot;: publicly available</span></strong><span> 指路由选择协议规范是公众可用的(与之相反的是 Cisco 的 EIGRP 协议)</span></p></li><li><p><span>使用 </span><strong><span>link-state routing</span></strong></p><ul><li><span>每个路由器将 OSPF link-state 通告 (advertisements) (直接通过IP而不是使用TCP/UDP)发送到整个AS中的所有其他路由器</span></li><li><span>多链路 costs metrics 可能: bandwidth, delay</span></li><li><span>每个路由器都有完整的 topology (拓扑结构)，采用Dijkstra算法计算转发表</span></li></ul></li><li><p><span>IS-IS路由协议: 几乎和OSPF一样</span></p></li><li><p><span>安全:所有 OSPF messages authenticated (消息验证，防止恶意入侵)</span></p></li><li><p><span>支持在单个 AS 中的层次结构:</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-03-22%20at%2018.43.54.png" referrerpolicy="no-referrer" alt="Screenshot 2023-03-22 at 18.43.54"></p><p>&nbsp;</p><h4 id='igrp'><span>IGRP</span></h4><p><span>IGRP: Interior Gateway Routing Protocol</span></p><ul><li><span>DV based</span></li><li><span>formerly Cisco-proprietary for decades (became open in 2013 [RFC 7868])</span></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id='54-routing-among-the-isps-bgp-dv'><span>5.4 routing among the ISPs: BGP (DV)</span></h3><p><img src="Typora_Picture/Screenshot%202023-04-15%20at%2018.54.52.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-15 at 18.54.52"></p><p><img src="Typora_Picture/Screenshot%202023-04-15%20at%2018.56.44.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-15 at 18.56.44"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id='06-link-layer-and-lans-点到点传输层功能'><u><span>06. Link Layer and LANs 点到点传输层功能</span></u></h2><ul><li><p><span>hosts and routers = nodes</span></p></li><li><p><span>沿着通信路径,连接个相邻节点的 communication path = links (wired, wireless, LANs)</span></p></li><li><p><span>第二层协议数据单元帧 frame, encapsulates datagram</span></p></li><li><p><span>数据报(分组)在不同的链路上以不同的链路协议传送:</span></p><ul><li><span>第一跳链路: Ethernet 以太网 (先坐飞机)</span></li><li><span>中间链路: 帧中继链路 (然后高铁)</span></li><li><span>最后一跳: 802.11 (最后轿车)</span></li></ul></li><li><p><span>不同的链路协议提供不同的服务（比如在链路层上提供(或没有)可靠数据传送）</span></p></li></ul><p><img src="Typora_Picture/Screenshot%202023-04-06%20at%2023.57.19.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-06 at 23.57.19"></p><p>&nbsp;</p><h3 id='61-services'><span>6.1 services</span></h3><ul><li><p><strong><span>framing, link access:</span></strong><span> </span></p><ul><li><p><span>将数据报封装在帧中，</span><strong><span>加上 header (帧头)、trailer (帧尾部)</span></strong></p></li><li><p><span>如果采用的是共享性介质，信道接入获得信道访问权</span></p></li><li><p><span>在帧头部使用“MAC”(物理)地址来标示源和目的 (不同于IP地址)</span></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.01.09.png" alt="Screenshot 2023-04-07 at 00.01.09" style="zoom:50%;" /></p></li></ul></li><li><p><strong><span>reliable delivery between adjacent nodes:</span></strong></p><ul><li><span>在低出错率的链路上(光纤和双绞线电缆)很少使用</span></li><li><span>在无线链路经常使用:出错率高</span></li></ul></li><li><p><strong><span>flow control:</span></strong><span> 使得相邻的发送和接收方节点的速度匹配</span></p></li><li><p><strong><span>error detection:</span></strong><span> 差错由信号衰减和噪声引起，接收方检测出的错误: 通知发送端进行重传或丢弃帧</span></p></li><li><p><strong><span>error correction:</span></strong><span> 接收端检查和纠正bit错误，不通过重传来纠正错误</span></p></li><li><p><strong><span>half-duplex and full-duplex: </span></strong></p><ul><li><span>半双工 (half-duplex): 链路可以双向传输，但一次只能收或只能发</span></li><li><span>全双工 (full-duplex): 但一次可以同时收或发</span></li></ul></li></ul><p>&nbsp;</p><h4 id='network-interface-card-网卡'><span>Network interface card 网卡</span></h4><ul><li><span>链路层功能在 </span><strong><span>适配器 adaptor (network interface card NIC)</span></strong><span> 上实现或者在一个 </span><strong><span>芯片组 (chip)</span></strong><span> 上</span></li><li><span>接到主机的系统总线上，硬件、软件和固件的综合体</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2014.08.46.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-05 at 14.08.46"></p><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2014.04.23.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-05 at 14.04.23"></p><p>&nbsp;</p><h3 id='62-error-detection-correction'><span>6.2 error detection, correction</span></h3><h4 id='621-error-detection-错误检测'><span>6.2.1 Error detection 错误检测</span></h4><ul><li><span>EDC: 差错检测和纠正位(冗余位) error detection and correction bits (e.g., redundancy)</span></li><li><span>D: 数据由差错检测保护，可以包含头部字段 data protected by error checking, may include header fields </span></li></ul><p><span>错误检测不是100%可靠的！协议会漏检一些错误，但是很少，更长的EDC字段可以得到更好的检测和纠正效果。</span></p><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2014.11.18.png" alt="Screenshot 2023-04-05 at 14.11.18" style="zoom:40%;" /></p><p>&nbsp;</p><h4 id='622-parity-checking-奇偶校验'><span>6.2.2 Parity checking 奇偶校验</span></h4><p><strong><span>Even Parity (偶校验):</span></strong><span> 发送方只需包含一个附加的比特，选择它的值，使得这d+1比特 (初始信息加上一个校验比特) 中1的总数是</span><strong><span>偶数</span></strong></p><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2014.16.54.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-05 at 14.16.54"></p><h4 id='623-internet-checksum-因特网检验和'><span>6.2.3 Internet checksum 因特网检验和</span></h4><p><span>与后面要讨论的常用于链路层的 CRC 相比，它们提供相对弱的差错保护</span></p><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2018.07.26.png" alt="Screenshot 2023-04-05 at 18.07.26" style="zoom:50%;" /></p><h4 id='624-cyclic-redundancy-check-crc-循环冗余校验'><span>6.2.4 Cyclic Redundancy Check (CRC) 循环冗余校验</span></h4><ul><li><span>强大的差错检测码</span></li><li><span>将</span><strong><span>数据比特 D</span></strong><span>, 看成是</span><strong><span>二进制的数据</span></strong></li><li><strong><span>生成多项式 G</span></strong><span>: 双方协商 r+1位模式(r次方)，生成和检查所使用的位模式</span></li></ul><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2018.26.44.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-05 at 18.26.44"></p><p><span>所有 CRC 计算采用 </span><strong><span>模2算术来做 = 异或 XOR (相同为0，不同为1)</span></strong></p><p><span>乘以 2^k 就是以一种比特模式左移 k 个位置，假设 D=101110, d=6 (位数), G=1001 和 r=3 (向左移3位) 的情况下的计算过程。 在这种情况下传输的 9 个比特是 101110011 。 你应该自行检查 一下这些计算，并核对 一 下 D * 2^k = nG XOR R 的确成立。</span></p><p><img src="Typora_Picture/Screenshot%202023-04-05%20at%2019.40.05.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-05 at 19.40.05"></p><p>&nbsp;</p><h3 id='63-multiple-access-protocols'><span>6.3 multiple access protocols</span></h3><ul><li><p><strong><span>分布式算法 -&gt; 决定把这个 共享式的channel 分配给哪个 node 来使用</span></strong><span>，即: 决定节点什么时候可以发送?</span></p></li><li><p><span>关于共享控制的通信必须用借助信道本身传输</span></p><ul><li><span>没有带外的信道，各节点使用其协调信道使用</span></li><li><span>用于传输控制信息</span></li></ul></li><li><p><span>节点通过这些协议来规范它们在共享的广播信道上的传输行为</span></p></li><li><p><span>两种类型的链路: 点对点, 广播 broadcast (共享线路或媒体)</span></p></li><li><p><strong><span>2个或更多站点同时传送: 冲突(collision)</span></strong><span>，多个节点在同一个时刻发送，则会收到2个或多个信号叠加</span></p></li><li><p><span>所以当多个节点处于活跃状态时，为了确保广播信道执行有用的工作，以某种方式协调活跃节点的传输是必要的。这种协调工作由多路访问协议负责。</span></p></li></ul><p>&nbsp;</p><p><strong><span>理想的 multiple access protocol:</span></strong></p><p><span>给定: </span><strong><span>multiple access channel (MAC)</span></strong><span> of rate </span><strong><em><span>R</span></em><span> bps</span></strong><span>，必要条件:</span></p><ul><li><span>当仅有一个节点发送数据时，该节点具有 </span><strong><span>R bps 的吞吐量</span></strong><span> </span></li><li><span>当有 </span><strong><span>M 个节点</span></strong><span>发送数据时，每个可以以</span><strong><span>R/M 的平均速率</span></strong><span>发送</span></li><li><span>协议是</span><strong><span>分散的</span></strong><span>; 这就是说不会因某主节点故障而使整个系统崩溃</span></li><li><span>协议是</span><strong><span>简单的</span></strong><span>，使实现不昂贵</span></li></ul><p>&nbsp;</p><h4 id='631-mac-protocols'><span>6.3.1 MAC protocols</span></h4><p><span>three broad classes:</span></p><ul><li><p><strong><span>channel partitioning 信道划分</span></strong></p><ul><li><span>把 channel 划分成更小的 &quot;pieces&quot; (time slots, frequency, code)</span></li><li><span>分配 pieces 给每个节点专用</span></li></ul></li><li><p><strong><span>random access 随机访问，想用的时候就用</span></strong></p><ul><li><span>channel 不划分，允许 collisions</span></li><li><span>冲突后恢复</span></li></ul></li><li><p><strong><span>taking turns 依次轮流</span></strong></p><ul><li><span>节点依次轮流，但是有很多数据传输的节点可以获得较长的信道使用权</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.05.56.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.05.56"></p><h4 id='632-channel-partitioning'><span>6.3.2 channel partitioning</span></h4><h5 id='channel-partitioning-mac-protocols-tdma'><span>Channel partitioning MAC protocols: TDMA</span></h5><p><span>将时间划 分为 时间帧 (time frame), 并进 一 步划分每个时间帧为 N 个时隙 (slot)</span></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.07.59.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.07.59"></p><ul><li><span>轮流使用信道，信道的时间分为周期</span></li><li><span>每个 站点(station) 使用每周期中</span><strong><span>固定的时隙</span></strong><span> (length = packet transmission time)传输帧</span></li><li><span>如果站点无帧传输，时隙空闲 -&gt; 浪费</span></li></ul><p><span>下面 6-station LAN，1、3、4 have packets to send，slot 2、5、6空闲</span></p><p><img src="Typora_Picture/Screenshot%202023-04-06%20at%2015.51.39.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-06 at 15.51.39"></p><p>&nbsp;</p><h5 id='channel-partitioning-mac-protocols-fdma'><span>Channel partitioning MAC protocols: FDMA</span></h5><ul><li><span>信道的有效频率范围被分成一个个小的频段</span></li><li><span>每个站点被分配一个固定的频段</span></li><li><span>分配给站点的频段如果没有被使用，则空闲</span></li></ul><p><span>下面 6-station LA，1、3、4 have packets to send，frequency bands (频段) 2、5、 6 idle (空闲)</span></p><p><img src="Typora_Picture/Screenshot%202023-04-06%20at%2023.39.28.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-06 at 23.39.28"></p><p>&nbsp;</p><h4 id='633-random-access-protocols'><span>6.3.3 Random access protocols</span></h4><ul><li><p><span>当节点有帧要发送时</span></p><ul><li><span>以信道带宽的</span><strong><span>全部 R bps</span></strong><span>发送</span></li><li><span>没有节点间的预先协调</span></li></ul></li><li><p><span>两个或更多 node 同时传输 ➜ 可能有 collision，涉及碰撞的每个节点将反复地重发它的 帧 (packet)，直到该帧无碰撞地通过为止 </span></p></li></ul><p><span>随机存取协议 (random access MAC protocol) 规定:</span></p><ul><li><span>如何检测冲突</span></li><li><span>如何从冲突中恢复(如:通过稍后的重传)</span></li></ul><p><span>examples of random access MAC protocols:</span></p><ul><li><span>unslotted ALOHA, slotted ALOHA</span></li><li><span>CSMA, CSMA/CD, CSMA/CA</span></li></ul><p>&nbsp;</p><h5 id='slotted-aloha'><span>Slotted ALOHA</span></h5><p><span>我们以最简单的随机接入协议之一：时隙 ALOHA (Slotted ALOHA) 协议，开始我们对 随机接入协议 (Random access protocols) 的学习</span></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.10.59.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.10.59"></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.12.12.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.12.12"></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.13.08.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.13.08"></p><p><img src="Typora_Picture/Screenshot%202023-04-07%20at%2000.24.20.png" referrerpolicy="no-referrer" alt="Screenshot 2023-04-07 at 00.24.20"></p><p>&nbsp;</p><h5 id='pure-unslotted-aloha-效率比时隙aloha更差'><span>Pure (unslotted) ALOHA 效率比时隙ALOHA更差！</span></h5><ul><li><p><span>简单、无须节点间在时间上同步，每个node各发各的不管别人</span></p></li><li><p><span>当有帧需要传输: 马上传输</span></p></li><li><p><span>冲突的概率增加:</span></p><ul><li><span>帧在t0发送，和其它在[t0 -1, t0 +1]区间内开始发送的帧冲突</span></li><li><span>和当前帧冲突的区间(其他帧在此区间开始传输)增大了一倍</span></li></ul></li></ul><p><img src="Typora_Picture/Screenshot%202023-04-22%20at%2014.17.26.png" alt="Screenshot 2023-04-22 at 14.17.26" style="zoom:50%;" /></p><p>&nbsp;</p><h4 id='634-csma-carrier-sense-multiple-access-礼貌的对话人'><span>6.3.4 CSMA (carrier sense multiple access) 礼貌的对话人</span></h4><p><span>CSMA (载波侦听多路访问): </span><strong><span>listen before transmit</span></strong><span>, 在传输前先侦听信道, 不打断别人正在进行的说话:</span></p><ul><li><span>如果侦听到信道 idle 空闲，传送整个帧</span></li><li><span>如果侦听到信道 busy 忙，推迟传送</span></li></ul><p><span>但是冲突仍然可能发生: 由 propagation delay 造成: 两个节点可能侦听不到正在进行的传输</span></p><p><span>冲突: 整个冲突帧的传输时间都被浪费了，是无效的传输(红 黄区域)</span>
<span>传播延迟(距离)决定了冲突的概率</span></p><p>&nbsp;</p><p><span>CSMA/CD (collision detection)</span></p><p>&nbsp;</p><h3 id='64-lans'><span>6.4 LANs</span></h3><p><span> • addressing, ARP and</span></p><p><span>RARP</span>
<span> • Ethernet • switches</span></p><p>&nbsp;</p><h3 id='65-a-day-in-the-life-of-a-web-request'><span>6.5 a day in the life of a web request</span></h3><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div></div>
</body>
</html>